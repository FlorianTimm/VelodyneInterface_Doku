\documentclass[a4paper,12pt,bibliography=totoc, listof=totoc,titlepage,pointlessnumbers]{scrreprt}
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage[left=3cm,right=2.5cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage[onehalfspacing]{setspace}
\renewcommand{\arraystretch}{1.5}
\usepackage{graphicx}
\usepackage{color}
\usepackage[toc,page]{appendix}
%\usepackage{pdfpages}  
\usepackage[hyphens]{url}
\usepackage[hidelinks]{hyperref}
\usepackage{todonotes}
\usepackage{amsmath}
%\usepackage{circdia/circdia}

\usepackage{multirow}

\newcommand*\justify{%
  \fontdimen2\font=0.4em% interword space
  \fontdimen3\font=0.2em% interword stretch
  \fontdimen4\font=0.1em% interword shrink
  \fontdimen7\font=0.1em% extra space
  \hyphenchar\font=`\-% allowing hyphenation
}

\newcommand{\code}[1]{\texttt{\justify{#1}}}
%\usepackage{tocloft}

%Boxfehler
\hbadness=10

% Listings
\usepackage{listings}
\lstset{
   breaklines=true,
   captionpos=t,
   basicstyle=\scriptsize\ttfamily,
   keywordstyle=\bfseries\ttfamily\color{orange},
   stringstyle=\color{green}\ttfamily,
   commentstyle=\color{gray}\ttfamily,
   emph={square}, 
   emphstyle=\color{blue}\texttt,
   emph={[2]root,base},
   emphstyle={[2]\color{yac}\texttt},
   showstringspaces=false,
   flexiblecolumns=false,
   tabsize=2,
   numbers=left,
   numberstyle=\tiny,
   numberblanklines=false,
   stepnumber=1,
   numbersep=10pt,
   xleftmargin=15pt
 }

% Zitierstil
%\usepackage[style=authoryear,citestyle=authoryear,natbib=true]{biblatex}
%\bibliography{Thesis.bib}
\usepackage[round]{natbib}
\bibliographystyle{hcu}

\begin{document}
\pagenumbering{Roman}
\begin{titlepage}
\begin{center}
\renewcommand{\arraystretch}{0.7}
\begin{tabular}{lr}
\begin{tabular}{l}
\includegraphics[width=0.4\textwidth]{img/hcu-hamburg.pdf}
\end{tabular} \hspace{1cm} &
\begin{tabular}{r}
Universität für \\Baukunst und Metropolenentwicklung\\
Studiengang Geomatik\\
Überseeallee 16\\
20457 Hamburg\\
\end{tabular}
\end{tabular}\\\vspace{5cm}
\doublespacing 
{\huge\bfseries  Entwurf und Implementation einer Daten-Schnittstelle zum Betrieb des Laser\-scan\-ners VLP-16 an einem
Rasp\-berry Pi}\vspace{0.5cm}\\
\onehalfspacing
{\large\bfseries Bachelorthesis}\vspace{2cm}\\
{\large vorgelegt von:}\\
{\large Florian Timm}\\

\vspace{7cm}
Mittwoch, den 13. Dezember 2017\\
\end{center}
\setcounter{page}{0} 
\end{titlepage}
\vspace{2cm}
\noindent\textbf{\large Verfasser}\\
Florian Timm\\
Matrikelnummer: 6028121\\
Gaiserstraße 2, 21073 Hamburg\\
\\
E-Mail: florian.timm@hcu-hamburg.de\\
\vspace{3cm}\\
\noindent\textbf{\large Erstprüfer}\\
Prof. Dr. Thomas Schramm\\
HafenCity Universität Hamburg\\
Überseeallee 16, 20457 Hamburg\\
\\
E-Mail: thomas.schramm@hcu-hamburg.de\\
\vspace{3cm}\\
\textbf{\large Zweitprüfer}\\
Dipl.-Ing. Carlos Acevedo Pardo\\
HafenCity Universität Hamburg\\
Überseeallee 16, 20457 Hamburg\\
\\
E-Mail: carlos.acevedo@hcu-hamburg.de\\
\newpage
\noindent\textbf{\large Kurzzusammenfassung}\\
Die vorliegende Arbeit ist Teil eines Projektes, das die Entwicklung eines Systems zum Ziel hat, welches den modular austauschbaren Betrieb verschiedenster Sensorsysteme an einem Multikopter erlauben soll. Im Speziellen soll hier die Datenschnittstelle von einem Kompakt-Laser\-scan\-ner Velodyne Lidar Puck VLP-16 zu einem Einplatinencomputer Rasp\-berry Pi entwickelt und implementiert werden. Der Scanner selbst liefert hierbei die Daten in einem proprietären, binären Format, welche in ein einfach lesbares Format, hier eine ASCII-Datei, umgewandelt und gespeichert werden sollen. Außerdem sollen die Daten mit einem eindeutigen Zeitstempel versehen werden, um diese später mit anderen Sensorsystemen verknüpfen zu können. Diese Datentransformation sollte möglichst simultan zur Aufnahme erfolgen.

Auch Teil der Arbeit ist die Schaffung einer Steuerung der Aufnahme des Laser\-scan\-ners. Hierfür wurde ein Bedienmodul entwickelt, welches am Rasp\-berry Pi direkt angeschlossen werden kann, sowie eine Weboberfläche entwickelt, die die Steuerung während des Fluges ermöglichen soll.\\
\vspace{2cm}\\
\noindent\textbf{\large Abstract}\\
This work is part of a project with the objective to develop a system that allows the modular interchangeable operation of various sensor systems on a multicopter. In particular, the data interface for the compact laser scanner Velodyne Lidar Puck VLP-16 to a single-board computer Rasp\-berry Pi will be developed and implemented. The scanner itself provides the data in a proprietary, binary format, which should be converted and stored into an easy-to-read ASCII file. In addition, the data should be provided with a unique timestamp in order to be able to link it later with other sensor systems. This data transformation should be carried out approximately on real time.

Also a control of the recording of the laser scanner should be constructed in this work. For this purpose, an operating module was developed, which can be connected directly to the Rasp\-berry Pi, as well as a web interface was integrated in the software, which should enable the control during flight.


% Mehrere gleichzeitig zitieren
\providecommand{\citeTwo}[4]{\citep[{\citealp[#1]{#2};}][#3]{#4}} 
\providecommand{\citeThree}[6]{\citep[{\citealp[#1]{#2}; \citealp[#3]{#4};}][#5]{#6}} 
\providecommand{\citeFour}[8]{\citep[{\citealp[#1]{#2}; \citealp[#3]{#4}; \citealp[#5]{#6};}][#7]{#8}}.

\newpage

\tableofcontents
\newpage

\pagenumbering{arabic}
\setcounter{page}{1} 

\chapter{Einleitung}

\section{Problemstellung}
Daten aus Air\-borne Laser\-scan\-ning, dem Abtasten von Oberflächen mit einem Laser\-scan\-ner aus der Luft, lassen sich für viele verschiedene Zwecke benutzen. Oft werden sie zur Erfassung von digitalen Geländemodellen verwendet, aber auch für die Erstellung von Stadtmodellen oder Vegetationsanalysen sind die Daten nutzbar. Aktuell werden als Trägersysteme des Laser\-scan\-ners Helikopter oder Flugzeuge verwendet, die mit entsprechender Sensorik ausgerüstet sind. Diese Messmethode lohnt sich allerdings nicht für die Vermessung kleinerer Gebiete. Auch sind Aufnahmen von Fassaden, bei denen zwischen Häuserschluchten geflogen werden müsste, nicht möglich. Das Fluggerät wäre hierfür zu groß und gefährlich. Desweiterwn sind die Betriebs- und Anschaffungskosten sehr hoch, so dass eine solche Messung oft nur für sehr große Gebiete wirtschaftlich ist. Alternativ bietet sich die terrestrische Messung mittels Tachymeter oder auch per Laser\-scan\-ner an, um kleinere Gebiete zu erfassen -- hier benötigt die Aufnahme jedoch viel Zeit und Personal. Hinzukommt, dass die Genauigkeit für viele Anwendungsfälle der 3D-Modelle zu hoch ist. Beide Möglichkeiten -- die Messung aus der Luft oder vom Boden -- sind sehr kostenintensiv. Ein Lösungsansatz hierfür wäre es, anstatt eines Helikopters als Trägersystem einen Multikopter zu nutzen. Jedoch ist die Tragfähigkeit für die meisten Laser\-scan\-ning-Systeme nicht ausreichend. Daher basieren bisherige 3D-Erfassungssysteme, die an Multikoptern genutzt werden, heutzutage meist auf photogrammetrischen Prinzipien, welche Luftbilder zur Erfassung nutzen. Hierzu muss jedoch ausreichend Beleuchtung vorhanden sein, welches wiederum den Einsatz des Systems in Städten beschränkt, in denen nur nachts für ausreichende Sicherheitszonen zum Betrieb von Multikoptern gesorgt werden kann. \citep{carlos}

\section{Projekt \& Zielsetzung}
Gesamtziel ist es, ein Laser\-scan\-ning-System zu entwickeln, das von einem Multikopter getragen werden kann. Hierbei soll vorallem auf ein geringes Gewicht geachtet, aber auch die Kosten niedrig gehalten werden. Ein solches System könnte die Lücke zwischen terrestrischem und klassischem Air\-borne Laser\-scan\-ning schließen \citep[S. 21f]{uav}. Im Speziellen soll hier als erster Schritt die Datenverarbeitung des Laser\-scan\-ners in einem solchen System realisiert werden. Hierfür soll ein Ein-Platinen-Computer vom Typ Rasp\-berry Pi 3 die Speicherung und Aufbereitung der von einem Laser\-scan\-ner des Modelles Velodyne Puck VLP-16 aufgezeichneten Laserpunktdaten übernehmen. Hierfür müssen entsprechende Schnittstellen zum Verbinden der Geräte in Hard- und Software entwickelt werden.

\section{Struktur}
Im \autoref{c:grundlagen} sollen die Grundlagen des luftgestützten Laser\-scan\-nings erläutert werden. Außerdem wird die benötigte Hardware zur Durchführung eines solchen Laser\-scan\-nings besprochen. Im Folgenden wird näher auf die Realisierung des Projektes eingegangen: Welche Hardware wurde verwendet und wie wurde Sie angeschlossen (\autoref{c:realisierung}), wie sollen die Daten verarbeitet werden (\autoref{c:datenverarbeitung}), wie wird die Verarbeitung schließlich durchgeführt (\autoref{c:skript}) und das System konfiguriert (\autoref{c:konfig}). Einzelne Komponenten werden in \autoref{c:systemueberpruefung} auf ihre Genauigkeit und Zuverlässigkeit geprüft. Zum Abschluss soll in \autoref{c:ausblick} noch ein Einblick in die Zukunft des Systems geworfen werden.

\chapter{Grundlagen des Air\-borne Laser\-scan\-nings}
\label{c:grundlagen}

Air\-borne Laser\-scan\-ning bezeichnet das Verfahren, bei dem ein Laser\-scan\-ner, welcher an einem Fluggerät befestigt ist, Oberflächen kontaktlos dreidimensional erfasst \citep[S. 1]{beraldin}. Der Laser\-scan\-ner liefert hierbei Daten in Form der Abstrahlrichtung des Strahles und der Entfernung, relativ zu seiner eigenen Ausrichtung und Position. Um diese lokalen Daten in ein globales System zu überführen, werden zusätzlich die Ausrichtung und die Position des Laser\-scan\-ners zum Zeitpunkt der Messung benötigt \citep[S. 22f]{beraldin}. Diese Daten liefern im Normalfall eine inertiale Messeinheit (siehe \autoref{s:IMU}) und ein Navigationssatellitenempfänger (siehe \autoref{s:GNSS}). Auf diese Bestandteile wird im Folgenden eingegangen. Anschließend werden einige bisherige Lösungsansätze zur dreidimensionalen Erfassung auf Basis von Multikopterplattformen vorgestellt.

\section{Laser\-scan\-ner}
Ein Laser\-scan\-ner besteht grundlegend aus einer Laser-Entfernungsmesseinheit und einer Ablenkeinheit. Für beide Teile gibt es verschiedenste Bauformen, die nachfolgend erläutert werden.

\subsection{Entfernungsmessung}
Für die Messung von Entfernungen mittels Laser\-scan\-ner gibt es zwei meistgenutzte Verfahren:

\paragraph{Impulsmessverfahren}
\label{p:tof}
Das bei Laser\-scan\-nern am häufigsten eingesetzte Verfahren ist das Impulsmessverfahren, englisch time-of-flight genannt. Hierbei werden einzelne Laserimpulse ausgesandt. Mit dem Aussenden startet ein hochgenauer Timer seine Messung. Bei dem Eintreffen des an einer Oberfläche reflektierten Strahles bei dem Laser\-scan\-ner wird der Timer gestoppt. Aus dieser gemessenen Laufzeit lässt sich die zurückgelegte Strecke des Lichtstrahles und somit die doppelte Entfernung zu der Oberfläche bestimmen. Hierzu wird der Brechungsindex \(n\) des vom Laser durchlaufenen Mediums benötigt. Bei der Messung durch Luft lässt sich dieser aus der Messung von Temperatur"~, Druck- und Luftfeuchte ausreichend genau berechnen. Aus der bekannten Lichtgeschwindigkeit \(c_0\) und der benötigten Zeit \(t\) lässt sich dann die Entfernung \(s\) mit der \autoref{equ:entfernung} berechnen.

\begin{equation}
\begin{aligned}
s &=  \frac{c_0}{n} \cdot \frac{t}{2}  && \left|\  \text{Streckenberechnung} \right. \\
\end{aligned}
\label{equ:entfernung}
\end{equation}

\paragraph{Phasenvergleichsverfahren}
Eine andere, für Airborne Laser\-scan\-ning selten verwendete Methode, ist das Phasenvergleichsverfahren. Hierbei wird nicht direkt die Zeit gemessen sondern die Phasenverschiebung eines kontinuierlichen Lichtstrahles, der mit einer Sinusschwingung amplitudenmoduliert wurde (Intensivitäts- bzw. Helligkeitsschwankungen). Hierdurch können weniger frequente Wellen (Modulationswelle) verwendet werden, wodurch sich bei guten Ausbreitungseigenschaften der hochfrequenten Trägerwellen die leichtere Verarbeitbarkeit von längeren Wellen ausnutzen lässt. Durch Messung des Phasenunterschiedes des Messstrahles, kann auf die Reststrecke der nicht-vollständigen Phasen des Messstrahles geschlossen werden. Als Trägerwelle wird normalerweise Infrarotlicht verwendet, da dieses gute Ausbreitungseigenschaften hat. Die hierfür benötigte Modulationswelle wird durch ein Quarzoszillator erzeugt. Ein hier verbautes Quarzplättchen wird durch Anlegen einer Spannung in eine Schwingung versetzt, die Schwingung verstärkt und an den Infrarot-Laser geleitet, so dass dieser das modulierte Infrarotlicht aussendet. Die maximale, eindeutig messbare Entfernung ist direkt von der längsten verwendeten Wellenlänge, dem Grobmaßstab, abhängig: Da nur die Phasenunterschiede und nicht die Anzahl der vollständigen Schwingungen gemessen werden können, ist die maximale, eindeutige Streckenmessung genau halb so groß wie die maximale Wellenlänge (Messung von Hin- und Rückweg). Wenn längere Strecken als die halbe Wellenlänge gemessen werden, ist nicht bekannt, wie viele ganze Wellen das Licht schon zurückgelegt hat. Die Messung wäre mehrdeutig. Zur Messung der Phase werden die ausgesendete und die eingehende Messwelle mit einer Überlagerungsfrequenz vermischt, die aus diesen beiden hochfrequenten Wellen eine niederfrequente Welle erzeugt. Da die Genauigkeit der Phasenverschiebungsmessung begrenzt ist, wird durch Nutzung verschiedener Wellenlängen eine Genauigkeitssteigerung erreicht. Nach der groben Messung mit einer langen Wellenlänge, wird die Genauigkeit durch die Verwendung immer kürzerer Modulationswellen gesteigert. Eine grobe Messung ist jedoch vorher notwendig, da ansonsten die Anzahl der ganzen Schwingungen des Messstrahles unbekannt ist. \citep[S. 311ff]{Witte2006}

\paragraph{Zeitmessung}
Bei beiden Verfahren ist die genaue Zeitmessung ein Problem. Eine Möglichkeit dieser Messung ist die Nutzung eines Frequenzgenerators, welcher Zähl\-imp\-ulse erzeugt. Diese werden dann zwischen zwei Flanken der zu messenden Ausgangs- und Eingangswellen mehrfach gezählt, gemittelt und ergeben so zum Beispiel die Phasenverschiebung. Dieses Verfahren wird als digitale Messung bezeichnet. Eine andere Methode ist die analoge Messung. Hierbei öffnet die eine Flanke den Stromfluss zu einem Kondensator, die Flanke der anderen Welle schließt sie wieder. Aus der Ladung des Kondensators kann dann auf den Phasenwinkel und die Phasenverschiebung geschlossen werden.  \citep[S. 314f]{Witte2006}

\subsection{Ablenkeinheit}
Bei den meisten Laser\-scan\-nern ist nur eine Laserentfernungsmesseinheit verbaut. Um hiermit verschiedene Punkte messen zu können, muss der Laserstrahl durch geeignete Verfahren abgelenkt werden. Auch hierfür gibt es im Air\-borne Laser\-scan\-ning verschiedenste Ansätze:
\citeTwo{S. 23ff}{ALS}{S. 16ff}{beraldin}

\paragraph{Schwenkspiegel}
Der Laserstrahl wird auf einen schwingenden, flachen Spiegel gerichtet. Durch die Schwingung wird der Laserstrahl in einer Ebene nach links und rechts abgelenkt. Durch die Bewegung des Fluggerätes wird der Laser in Richtung der Schwingachse bewegt. Es entsteht eine Zick-Zack-Linie auf der Oberfläche als Messmuster.

\paragraph{Rotierender Polygon-Spiegel}
Bei diesem Typ dreht sich ein Prisma mit einem gleichseitigen Polygon als Grundläche in der Achse der Flugbewegung. Seine  Seiten sind verspiegelt und der Laser auf diese gerichtet. Von oben gesehen wird der Strahl somit immer nur in eine Richtung abgelenkt und springt beim Überstreifen der Kante  wieder zurück auf die andere Seite. Es entsteht ein Streifenmuster.

\paragraph{Palmer-Scanner}
Bei dem Palmer-Scanner rotiert ein Flachspiegel um eine Achse, die fast senkrecht zur Spiegeloberfläche steht. Da der Spiegel nicht genau senkrecht auf dieser Achse montiert ist, beschreibt der auf den Spiegel gerichtete Laser einen Kreis. Durch einen im 45 Grad Winkel zur Achse stehenden Spiegel und einem sich in der Drehachse befindlichen Scanner können die Strahlen auch rechtwinklig abgelenkt werden und somit eine Ebene scannen. Dies wird häufig bei terrestrischen Laser\-scan\-nern im Zusammenhang mit einer zweiten Drehachse angewandt.

\paragraph{Glasfaser-Scanner}
\label{p:faserscanner}
Der Glasfaser-Scanner nutzt zur Ablenkung zusätzlich Glasfasern, welche fest verbaut sind. Hierdurch sind die Ablenkungswinkel fest vorgegeben. Beispielsweise ein Polygonspiegel wie er zuvor beschrieben wurde, reflektiert den Messstrahl in das jeweilige Faserbündel. 

\paragraph{Zusätzliche Achsen}
Zusätzlich zu den Spiegelmechanismen verfügen die terrestrischen Laser\-scan\-ner über eine weitere Achse. Während bei dem Air\-borne Laser\-scan\-ning die weitere Bewegung des Lasers durch die Fortbewegung des Fluggerätes durchgeführt wird, muss dies bei der terrestrischen Messung ein Motor übernehmen. Panorama-Laser\-scan\-ner haben hierfür einen Drehmechanismus um ihre Hochachse. Bei Kamera\-scannern, sie messen nur eine quadratische Fläche wie eine Kamera, kann die zusätzliche Bewegung auch einfach durch einen zweiten Ablenkungsspiegel erfolgen. \citep[S. 37]{beraldin}

Zusätzlich haben alle Ablenk- und Drehsysteme eine Messeinheit, die den Stand des Spiegels misst. Hierdurch lässt sich dann die Abstrahlrichtung des Lasers berechnen, beziehungsweise bei dem Faserlaser bestimmen, welches Faserbündel genutzt wurde. Die Richtung wird dann wiederum zur Berechnung von Koordinaten benötigt.

\subsection{Oberflächeneffekte}
Der vom Laser ausgesendete Impuls wird nur bei rechtwinklig zur Strahlenachse verlaufenden, ebenen Oberflächen als identischer, abgeschwächter Impuls zurückgestrahlt. Der Laser trifft bei der Messung nicht, wie idealisiert angenommenen, punktförmig auf die Oberfläche, sondern stellt einen Kreis beziehungsweise bei schrägem Auftreffen eine Ellipse mit einer bestimmten Größe, dem sogenannten Footprint dar. Hierdurch ergeben sich je nach Oberfläche verschiedene Reflexionen: Bei einer zu dem Laserstrahl schrägen Oberfläche wie einem Dach wird das Signal geweitet, die Impulsdauer des reflektierten Strahles (Echo) wird verlängert, da er auf der Oberfläche zeitversetzt auftrifft. Ein anderes Phänomen sind mehrfache Echos. Dies tritt auf, wenn zwei unterschiedlich weite entfernte Oberflächen von einem Strahl getroffen werden -- zum Beispiel bei der Messung von Gebäudekanten oder Bäumen. \autoref{img:echo} zeigt solche Echos in grafischer Form. \citep[S. 28]{beraldin}

\begin{figure}[!ht]
 \centering
 \includegraphics[width=0.6\textwidth]{./img/echo.pdf}
 % vlp16.jpg: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{Reflektiertes Signal je nach Oberfläche, nach \citet[S. 28]{beraldin}}
 \label{img:echo}
\end{figure}

Laser\-scan\-ner mit Impulsmessverfahren ermöglichen typischerweise bis zu vier einzelne Echos aufzuzeichnen. Alternativ gibt es Scanner, die das komplette Signal mit einer Abtastrate von bis zu 0,5 Nanosekunden digitalisieren. Hier ist es dann möglich, spezielle Auswertungen aufgrund der Wellenform im Postprocessing durchzuführen. \citep[S. 29]{beraldin}

\section{Positionsbestimmung mittels globalen Navigationssatellitensystemen}
\label{s:GNSS}
Zur Bestimmung der Position des Fluggerätes wird ein Empfänger für globale Navigationssatellitensysteme (global navigation satellite system, GNSS) verwendet. Ein solcher Empfänger kann durch die Laufzeitbestimmung des Signales von verschiedenen Satelliten, zum Beispiel des US-amerikanischen Navstar GPS, seine aktuelle Position bestimmen. Hierzu ist eine freie Sicht zum Himmel notwendig. Je nach Auswertung und Weiterverarbeitung des Signales sind verschiedene Genauigkeiten möglich. Ohne zusätzliche Daten beträgt sie etwa 5 Meter. Durch die Nutzung von Referenzstationsnetzen wie SAPOS können Genauigkeiten von 1-2cm in Echtzeit in Bewegung oder bei statischen Dauermessungen von wenigen Millimetern erreicht werden. Es befinden sich pro weltweiten System etwa 30 Satelliten in einer bekannten Umlaufbahn. \citep[S. 375]{Witte2006}
Durch an Bord befindliche Atomuhren können die Satelliten hochgenaue Zeitstempel und sich wiederholende Codemuster aussenden. Im Fall von Navstar GPS erfolgt die Aussendung aktuell auf drei verschiedenen Frequenzen L1, L2 und L5. Für die öffentliche Nutzung ist nur L1 freigegeben. L2 und L5 sind der militärischen Nutzung vorbehalten. Durch reine Auswertung des ausgesendeten L1-Codes können Genauigkeiten bis 5 Meter erreicht werden. Für geodätische Anwendungsfälle wird zusätzlich die Phasenmessung benutzt. Hierbei wird nicht nur das dem Funksignal aufmodelierte Codemuster ausgewertet, sondern auch die Phase des Signals. Hierdurch ist es auch möglich, dass verschlüsselte L2-Signal mitzunutzen. \citep[S. 10f]{Witte2006}

\section{Inertiale Messeinheit}
\label{s:IMU}
Bei der inertialen Messeinheit (inertial measurement unit, IMU) handelt es sich um einen Sensor, der die Neigung sowie Drehbewegungen der Sensoreinheit misst. Sie wird benötigt, um bei dem Air\-borne Laser\-scan\-ning die genaue Ausrichtung des Laser\-scan\-ners im Raum zu bestimmen. Daher muss diese auch verwindungssteif mit dem Laser\-scan\-ner verbunden sein. In Kombination mit den Positionsdaten des GNSS-Modules ermöglicht sie die Rekonstruktion der Flugbewegungen (Trajektorie). Ein weiterer Vorteil der inertialen Messeinheit ist ihre Messfrequenz: Im Gegensatz zum GNSS, dass im Normalfall nur eine Messung pro Sekunde durchführt, kann die IMU bis zu 500 Messungen pro Sekunde ausführen. Sie stützt daher nicht nur die GNSS-Messung, sondern hilft auch die Trajektorie zu interpolieren und somit auch für den Bereich zwischen den GNSS-Messungen genaue Positionen zu bestimmen. \citep[S. 23ff]{beraldin}

Die Messung erfolgt mit mehreren Einzelsensoren: Für die Messung der Beschleunigung in drei Dimensionen sind drei jeweils rechtwinklig zueinander stehende Beschleunigungsmesser verbaut. In der klassischen Bauform ist hierfür jeweils eine Probemasse zwischen zwei Federn gelagert. Durch eine auf die Probemasse wirkende Beschleunigung wird diese zwischen den Federn ausgelenkt. Die Messung der Drehrate erfolgt mittels drei einzelnen Kreiselinstrumenten (Gyroskop) in drei Achsen. Sie basieren auf Kreiseln, welche drehbar gelagert sind. Sie streben dazu, die Ausrichtung ihrer Drehachsen im Raum beizubehalten. Durch Messung der Kräfte kann die Drehrate berechnet werden. Einige inertiale Messeinheiten enthalten auch ein dreidimensionales Magnetometer, mit dem sich die magnetische Nordrichtung dreidimensional feststellen lässt. \citep[S. 10]{willemsen}

Die Genauigkeit von inertialen Messeinheiten wird in ihrer Messauflösung und in ihrer zeitliche Richtungsabweichung, der Drift, angegeben. Die zeitliche Stabilität ist vorallem bei der Inertialnavigation wichtig, bei der die Ortsbestimmung nur auf Grundlage der Messungen der IMU erfolgt.

\begin{figure}[!ht]
 \centering
 \includegraphics[width=0.6\textwidth]{./img/mems.jpg}
 % vlp16.jpg: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{MPU-9250 - Low-Cost-MEMS-IMU-Modul wie es in vielen Consumer-Geräten und Multikoptern verwendet wird (schwarzes Bauteil mittig auf der Platine, eigene Aufnahme)}
 \label{img:mems}
\end{figure}

Hauptsächlich unterschieden werden die inertialen Messeinheiten in klassische, mechanische Systeme, wie sie bereits hier beschrieben wurden, und mikroelektromechanische Systeme, sogenannte MEMS (microelectromechanical systems). Bei den zweitgenannten handelt es sich um stark miniaturisierte Bauteile (beispielsweise \autoref{img:mems}), welche zum Beispiel auch in aktuellen Smartphones eingesetzt werden. Sie werden für Zwecke eingesetzt, in denen keine hohen Genauigkeitsanforerungen gestellt werden und der Preis gering gehalten werden soll. Auch zur Stabilisierung der Fluglage von Multikoptern oder Gimbals werden diese Sensoren eingesetzt.\citep[S. 9f]{willemsen}

Für geodätische Anwendungsfälle werden meist noch mechanische Systeme genutzt, da deren Genauigkeit und ihr Drift geringer sind. Höherpreisige MEMS-Sensoren erreichen jedoch auch bereits gute Genauigkeiten. \citep{imar}

\section{Kombination der Messsysteme}
Um die drei eigenständigen Messsysteme kombiniert nutzen zu können, muss die relative Position der Systeme genau bekannt sein und darf sich während des Fluges nicht verändern. Bei dem klassischen Air\-borne Laser\-scan\-ning vom Helikopter werden hierfür zum Beispiel eigenständige Module entwickelt, die alle benötigten Systeme verdrehsicher enthalten und an den Kufen des Helikopters montiert werden können. Außerdem müssen alle Systeme synchronisiert werden, damit die Daten später miteinander verarbeitet werden können. Hierfür wird üblicherweise das Sekundensignal des Navigationssatellitensystems (pulse per second, PPS) genutzt. Das GNSS-System sendet dazu zu jeder vollen Sekunde der GNSS-Zeit ein Impuls aus, mit welchen sich die anderen Sensorsysteme synchronisieren können. \citep[S. 23f]{beraldin}

\section{Bisherige Systeme zur dreidimensionalen Erfassung mittels Multikoptern}
Die meisten aktuellen Verfahren zur Erzeugung von 3D-Modellen unter Nutzung von kompakten Multikoptern mit einer Tragkraft von bis zu 5kg, basieren auf photogrammetrischen Verfahren \citep{carlos}. Sie erzeugen Bilder, meist unter direkter Georeferenzierung \cite[S. 16f]{uav}, welche im Postprocessing zu Bildverbänden verknüpft werden. Mittels automatischer Bildauswertung werden hieraus 3D-Punktwolken berechnet \cite[S. 18f]{uav}. Nachteil dieses Verfahrens ist es, dass ausreichende Beleuchtung vorhanden sein muss. Es kann somit nur tagsüber geflogen werden, aber auch starke Schatten können das Ergebnis verschlechtern. Für die automatische Erstellung von Punktwolken muss außerdem das Gelände ausreichende Strukturen aufweisen, damit die automatische Verknüpfungen der Pixel erfolgen können.

Laser\-scan\-ning, als aktiver Sensor, hat hier den Vorteil, dass keine zusätzliche Beleuchtung benötigt wird -- der Sensor bringt sein Licht selber mit. Problematisch ist hierbei jedoch die Größe der Systeme. Aus diesem Grund wurden bisher hauptsächlich Systeme mit großen UAVs erprobt und verwendet. Durch die immer weiter fortschreitende Miniaturisierung und die Weiterentwicklung von Laser\-scan\-nern, zum Beispiel für die Entwicklung von autonomen Fahrzeugen, werden die Scanner auch inzwischen kleiner und leistungsfähiger. \citep[S. 19]{uav}

\chapter{Technische Realisierung}
\label{c:realisierung}


Im Folgenden wird zunächst auf die verwendeten Sensoren und Geräte und ihre technischen Eigenschaften eingegangen, bevor danach auf die technischen Verbindungen der Komponenten eingegangen wird.

\section {Verwendete Sensoren und Geräte}

\subsection{Velodyne VLP-16}
\label{sss:vlp16}
Um Gewicht zu sparen, wird für die Messung ein miniaturisierter Laser\-scan\-ner eingesetzt. Einer dieser Kompakt-Laser\-scan\-ner ist der Velodyne Puck VLP-16 (siehe \autoref{img:vlp16}). Sein Durchmesser beträgt 10,3~cm, seine Höhe 7,3~cm  und sein Gewicht 830~g ohne Kabel und Schnittstellenbox. Es handelt sich bei dem VLP-16 mit 16 Messstrahlen, der sich zusätzlich um seine Hochachse dreht. Wahrscheinlich handelt es sich um einen Glasfaser-Scanner, Angaben macht der Hersteller hierzu jedoch keine. Seine Messgenauigkeit beträgt laut Datenblatt 3~cm. Gemessen wird im Impulsmessverfahren (siehe \autoref{p:tof}) mit einem 903nm-Infrarotlaser. \citep{vlpSheet}

Der Scanner sendet die Messstrahlen mit einem Zeitabstand von 2,3~$\mu$s aus, gefolgt von einer Nachladezeit von 18,4$\mu$s, so dass jeder Messstrahl alle 55,3~$\mu$s ausgesendet werden kann \citep[S. 16]{vlpManual}. Es ergibt sich somit eine durchschnittliche Messfrequenz von 289~357~Hz (siehe \autoref{equ:XproS}). Während der Messungen dreht sich der Laser\-scan\-ner je nach Einstellung über das Webinterface des Scanners mit 5 bis 20 Umdrehungen pro Sekunde \citep{vlpSheet}. Pro ausgesendeten Strahl können jeweils die stärkste und die letzte Reflexion zurück gegeben werden, so dass über eine halbe Million Punkte pro Sekunde gemessen werden können (siehe \autoref{equ:XproS}). Die Daten werden anschließend über den Netzwerkanschluss gestreamt (siehe auch \autoref{ss:Datenlieferung}). Außerdem verfügt der Scanner über einen Anschluss für ein GNSS-Modul des Types Garmin GPS 18x LVC. Auch andere GNSS-Module sind nutzbar, so dass im Weiteren versucht wurde, ein uBlox-GNSS-Modules zu nutzen (siehe \autoref{s:GNSSAnschluss}). Durch die Nutzung eines GNSS-Modules am Scanner ist es möglich, die Daten mit einem hochgenauen Zeitstempel zu versehen und die Messungen des Scanners so mit den Daten aus der inertialen Messeinheit zu verknüpfen.

\begin{equation}
 \label{equ:XproS}
 \begin{aligned}
  f &= \frac{1s}{55,295\mu s} \cdot 16~\frac{\text{Messstrahlen}}{\text{Messung}} = 289~357~\frac{\text{Messung}}{\text{Sekunde}} \\
  n &= 289~357~\frac{\text{Messung}}{\text{Sekunde}} \cdot 2~\frac{\text{Messwerte}}{\text{Messtrahl}} = 578~714~\frac{\text{Messwerte}}{\text{Sekunde}}
 \end{aligned}
\end{equation}

\begin{figure}[!ht]
 \centering
 \includegraphics[width=0.6\textwidth]{./img/vlp16.jpg}
 % vlp16.jpg: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{Laser\-scan\-ner Velodyne VLP-16 (eigene Aufnahme)}
 \label{img:vlp16}
\end{figure}

\subsection{Inertiale Messeinheit und GNSS-Empfänger iMAR iNAT-M200-FLAT}
\label{s:iMar}
Als inertiale Messeinheit wird das auf \autoref{img:imu} zu sehende Sensorsystem des Typs iMAR iNAT-M200-FLAT verwendet. Hierbei handelt es sich um ein hochgenaues MEMS-System. Durch die Verwendung von mikroelektromechanischen Bauteilen wiegt der Sensor inklusive Gehäuse nur 550 Gramm. Er kann bis zu 500 Messungen pro Sekunde durchführen. Die Abweichung der Drift pro Stunde liegt unter 0,5\(^\circ\). \citep{imar}

\begin{figure}[!ht]
 \centering
 \includegraphics[width=0.7\textwidth]{./img/imu.jpg}
 % vlp16.jpg: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{iMAR iNAT-M200-Flat im Prototypen des modularen Gehäuses, Leitungen führen zu den GNSS-Antennen (eigene Aufnahme)}
 \label{img:imu}
\end{figure}

Außerdem verfügt die verwendete Einheit über zwei differentielle Satellitennavigationsempfänger (GNSS-Module, siehe \autoref{img:gnss}). Durch Nutzung einer zusätzlichen GNSS-Basisstation oder auch einem entsprechenden Korrekturdienst können diese eine Positionsgenauigkeit von etwa 2 Zentimeter in Echtzeit erreichen \citep{imar}. Durch Postprocessing lässt sich diese sogar noch steigern. Durch die Verwendung von zwei Empfängern, die an jeweils einem Ausleger befestigt sind (siehe Bild \autoref{img:gnss}), kann auch die Orientierung des Scanners bestimmt werden. Hierdurch kann die durch Störungen, wie den Motoren des Multikopters, möglicherweise ungenaue Messung der magnetischen Nordrichtung kontrolliert werden. Außerdem kann die Positionssicherheit durch Mittlung der beiden Positionen erhöht werden und auch der Drift durch die Daten eliminiert werden.

\begin{figure}[!ht]
 \centering
 \includegraphics[width=0.8\textwidth]{./img/gnss.jpg}
 % vlp16.jpg: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{GNSS-Antenennen des (links und rechts) iMAR iNAT-M200-Flat an Prototypen des modularen Gehäuses (eigene Aufnahme)}
 \label{img:gnss}
\end{figure}

Im Postprocessing kann aus den Daten der inertialen Messeinheit zusammen mit denen der GNSS-Module und GNSS-Korrekturdaten eine genaue Flugbahn des Multikopters berechnet werden. Die Daten der inertialen Messeinheit werden hierbei regelmäßig durch die Daten der GNSS-Module gestützt.
\citet{wilken} untersuchte in seiner Bachelorthesis die Genauigkeit des Empfängers im Vergleich zu einem geodätischen GNSS-Empfänger. Seine Messungen bestätigten die angegebenen Genauigkeiten. Jedoch traten Probleme bei der Nutzung der zweiten GNSS-Antenne auf, so dass nicht die Position der IMU zwischen den beiden Antennen ermittelt wurde, sondern die Position der primären Antenne. Das GNSS des IMU-Moduls ist daher aktuell noch nicht voll einsetzbar, da dieses Problem zuvor gelöst werden muss.

\subsection{Rasp\-berry Pi 3 Typ B}
\label{ss:Raspberry}
Die Verarbeitung der Daten soll mit einem Rasp\-berry Pi 3 (siehe \autoref{img:rpi3}) erfolgen. Es handelt sich hierbei um einen von der Rasp\-berry Pi Foundation entwickelten Einplatinencomputer. Die Stiftung gründete sich 2006, um einen erschwinglichen Computer zu entwickeln, an dem Schüler direkt Hardware- und Elektronikprojekte entwickeln können. Die erste Version des Rasp\-berry Pi kam im Februar 2012 auf den Markt. Er verfügte über 256 MB Arbeitsspeicher und einen 700 MHz Ein-Kern-Prozessor. Das verwendete dritte Modell verfügt über einen Vier-Kern-Prozessor mit 1,2 Ghz und 1 GB Arbeitsspeicher. Bisher wurden alle Versionen zusammen über 11 Millionen mal verkauft (Stand November 2016). \citep{heise5Rasp}

Alle Modelle der Rasp\-berry Pi Serie basieren auf Ein-Chip-Systemen des Halbleiterherstellers Broadcom. In diesem Chip sind die wichtigsten Bauteile des Systems integriert wie zum Beispiel ein ARM-Prozessor, eine Grafikeinheit sowie verschiedene andere Komponenten. Die so gering gehaltene Anzahl an einzelnen Bauelementen bei dem Rasp\-berry Pi ermöglichen den geringen Preis - ein Ziel der Rasp\-berry Pi Foundation. 

Vorteilhaft bei der Nutzung des Rasp\-berry Pi zur Datenverarbeitung sind vor allem seine verschiedensten Schnittstellen zur Daten Ein- und Ausgabe \citep{raspSheet}:
\begin{itemize}
 \item 4 USB 2.0 Host-Anschlüsse
 \item Netzwerkschnittstelle (RJ45)
 \item Bluetooth- und WLAN
 \item 27 GPIO-Ports, nutzbar als \citep{ekRaspPin}
 \begin{itemize} 
  \item Digitale Pins
  \item Serielle Schnittstelle
  \item I2C-Schnittstelle
  \item SPI-Schnittstelle
 \end{itemize}
 \item Stromversorgung 3,3V und 5V
 \item MicroUSB-Anschluss zur eigenen Stromversorgung (5V)
 \item MicroSD-Steckplatz 
 \item verschiedene Video- und Audioausgänge
 \end{itemize}

Praktisch für die Nutzung am Multikopter ist außerdem seine geringe Größe und sein relativ geringer Stromverbrauch von maximal 12,5 Watt \citep{raspSheet}. Im Betrieb ohne weitere Peripherie außer einem GNSS-Chip wird dieser Stromverbrauch bei weitem nicht erreicht, hier wurden durchschnittlich nur 2,5 Watt gemessen.

\begin{figure}[!ht]
 \centering
 \includegraphics[width=0.7\textwidth]{./img/rpi3.jpg}
 % vlp16.jpg: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{Rasp\-berry Pi 3 (eigene Aufnahme)}
 \label{img:rpi3}
\end{figure}

Alternativ zum Raspberry Pi kämen zur Datenverarbeitung an Bord des Multikopters auch Mikrokontroller-Boards wie die der Arduino-Serie in Frage. Vorteile eines Arduinos wären vorallem der geringere Stromverbrauch und die Echt-Zeitfähigkeit. Jedoch ist die Steuerung der Datenaufnahme über die Netzwerkschnittstelle und die Speicherung deutlich komplizierter und die Hardware nicht so leistungsfähig. Bei dem Rasp\-berry Pi übernimmt das Betriebssystem die grundlegenden Steuerungen, so dass nur noch die Daten selbst verarbeitet werden müssen. Außerdem bietet er mit den festverbauten Schnittstellen auch die komplette benötigte Hardware, die so nicht einzeln zusammengestellt beziehungsweise "~gebaut werden muss.


\subsection{Multikopter Copterproject CineStar 6HL}
Bei einem Multikopter handelt es sich um ein Fluggerät mit drei oder mehr Rotoren. Weit verbreitetet sind vorallem Quadrokopter mit vier oder den Hexakopter mit sechs Rotoren, welcher in dieser Arbeit betrachtet wird. Multikopter wurden ursprünglich für Militär- und Polizeizwecke eingesetzt, inzwischen sind sie aber auch vermehrt in kleineren Ausführungen im Privatbesitz zum Beispiel für Videoaufnahmen zu finden \citep{Quadro}. Angetrieben werden die handelsüblichen Modelle, welche eine Flugdauer von bis zu 30 Minuten und eine Tragkraft von bis zu fünf Kilogramm aufweisen, mit Lithium-Polymer-Akkumulatoren (LiPo-Akkus). Die Anzahl und die maximale Umdrehung der Rotoren bestimmt die Schubkraft und somit auch die Tragkraft des Multikopters. Im Normalfall besitzen sie eine gerade Anzahl von Rotoren, damit sich das auf das Traggestell wirkende Drehmoment aufhebt. Hier liegt auch der Vorteil der Bauform gegenüber einem Hubschrauber, bei welchem mit einem Heckrotor dem Drehmoment um die Hochachse entgegengewirkt werden muss. Die einzelnen Motoren und Propeller werden kreuzweise angeordnet, so dass eine Drehzahländerung eines Propellerpaares zur Steuerung ausreicht. Vorteil eines Multikopters im Gegensatz zu einem Modellflugzeug ist es außerdem, dass er senkrecht starten kann und auch zum Beispiel für die Aufnahme von Bildern auf der Stelle stehen bleiben kann. Nachteil ist der höhere Energieverbrauch, so dass Modellflugzeuge bei gleicher Akkukapazität deutlich länger in der Luft bleiben können. \citep{Bachfeld}

\begin{figure}[!ht]
 \centering
 \includegraphics[width=0.6\textwidth]{./img/uav.jpg}
 % vlp16.jpg: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{Multikopter Copterproject CineStar 6HL mit Gimbal Freefly MöVI M5 (eigene Aufnahme)}
 \label{img:uav}
\end{figure}

Für dieses Projekt soll der Multikopter den Laser\-scan\-ner, die IMU, das Gimbal, die Stromversorgung, Datenverarbeitung und "~speicherung im Betrieb tragen können. Bei der Systementwicklung des Multikopters muss daher darauf geachtet werden, dass das Gewicht möglichst gering bleibt. Dennoch müssen die angehängten Messeinrichtungen auch gegebenfalls für härtere Landungen ausgelegt sein. Der verwendete Hexakopter (siehe \autoref{img:uav}) hat eine Tragkraft von maximal 5 Kilogramm und eine Flugdauer von bis zu 20 Minuten \citep{Schulz}.

\subsection{Gimbal Freefly MöVI M5}
Um die Messgeräte während des Fluges des Multikopters zu stabilisieren und zu verhindern, dass sich jede Neigung durch die Flug\-steuerung an den Laser\-scan\-ner überträgt, wird ein sogenanntes Gimbal verwendet. Durch einen Regelkreis aus Motoren und einer inertialen Messeinheit (siehe auch \autoref{s:IMU}) werden Neigungen und Drehungen in Echtzeit ausgeglichen. Außerdem ermöglichen es die meisten Gimbals, die Messtechnik unabhängig vom Multikopter auszurichten - dies ist zum Beispiel bei der Luftbildaufnahme wichtig.

Für das Projekt wird ein Gimbal des Herstellers Freefly verwendet. Sie wurde zur Stabilisierung von Aufnahmen mit digitalen Spiegelreflexkameras entwickelt und hat eine Tragkraft von 2,3 Kilogramm. Außer den erwähnten Beschleunigungsmesser verwendet diese auch GNSS um das Driften der integrierten IMU zu vermindern. \citep{movim5}

\section{Stromversorgung}
Die Stromversorgung des Rasp\-berry Pi an dem Multikopter soll mittels Lithium-Ionen-Zellen erfolgen. Der Rasp\-berry Pi benötigt hierbei eine stabilisierte Spannungs- und Stromversorgung. Eine fehlerhafte Stromversorgung kann zu Systeminstabilitäten führen und so im schlimmsten Fall die Datenaufzeichnung komplett verhindern. Auf den genauen Aufbau einer solchen Versorgung wird hierbei verzichtet, sondern nur die Anforderungen an die Energiequelle erläutert.

\autoref{tab:strom} listet die verschiedenen Module und die jeweils benötigte Energieversorgung auf. Der Multikopter mit der Gimbal verfügt über eine eigene Versorgung und muss daher nicht weiter beachtet werden. Außerdem hat hier eine eigene Akkukapazität auch Vorteile - auch bei einem zu hohen Verbrauch der Sensortechnik bleibt der Multikopter durch seine eigenständige Akku-Überwachung immer noch flugfähig um sicher landen zu können.

\begin{table}[!ht]
\centering
\begin{tabular}{ l | r | r | r }
  Gerät 	& Laser\-scan\-ner	& IMU		& Rasp\-berry Pi\\
  \hline
  Spannung 	& 9 - 18 V 	& 10 - 36 V	& 5,0 V \\
  \hline
  max. Strom 	& 0,9 A		& 0,75 A	& 2,5 A \\
  \hline
  typ. Leistung	& 8 W		& 7,5 W		& 12,5 W 
\end{tabular}
\caption{Spannungs- und Strombedarf der einzelnen Module \citep{vlpSheet,imar,raspSheet}}
\label{tab:strom}
\end{table}

Für eine geplante Flugdauer von 30 Minuten wird bei einem angenommenen Wirkungsgrad von 90\% eine Akkukapazität von mindestens 16 Wh (siehe \autoref{equ:akku}) benötigt. Außerdem muss ein Teil in 12 Volt und ein Teil mit 5 Volt stabilisierter Spannung abgeben werden können. Gegebenenfalls sind hierfür auch zwei komplett unabhängige Spannungsquellen zu nutzen.

\begin{equation}
\label{equ:akku}
E = \frac{ P \cdot t}{\eta} = \frac{(8~W + 12,5~W + 7,5W) \cdot 0,5~h}{90~\%} \approx 15,6~Wh
\end{equation}

\section{Verbindung des Rasp\-berry Pi an den Laser\-scan\-ner}
Der Laser\-scan\-ner wird mit einem RJ45-Kabel an der Netzwerkschnittstelle des Raspberry Pi angeschlossen. Die inertiale Messeinheit zeichnet die Daten selbst\-stän\-dig auf, kann aber auch mittels der als serieller Schnittstelle nutzbaren GPIO-Pins an den Rasp\-berry Pi angeschlossen werden. Außerdem kann an diesen Port auch ein GNSS-Modul angeschlossen werden. Dieses GNSS-Modul wird im Folgenden benutzt, um dem Rasp\-berry Pi und dem Laserscanner eine genaue Uhrzeit zu liefern, welche für die Verarbeitung der Daten benötigt wird. Alternativ kann auch ein nur an den Laser\-scan\-ner angeschlossenes GNSS-Modul sein Zeitstempel per Netzwerk an den Rasp\-berry Pi liefern.

\section{Verbindung des GNSS-Modules an den Laser\-scan\-ner}
\label{s:GNSSAnschluss}
Für die Versorgung des Laser\-scan\-ners mit einem GNSS-Signal zur Synchronisierung wurde ein zusätzliches GNSS-Modul vom Typ uBlox NEO-6M mit PPS-Signal ausgewählt (ähnlich dem auf \autoref{img:ublox}), da dieses kleiner und leichter ist, als die entsprechenden Adapterkabel der inertialen Messeinheit um dessen Signal nutzen zu können.

\begin{figure}[!ht]
 \centering
 \includegraphics[width=0.6\textwidth]{./img/ublox.jpg}
 % vlp16.jpg: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{uBlox NEO-M8N, das Vorgängermodell NEO-6M mit PPS-Ausgang wurde verwendet (eigene Aufnahme)}
 \label{img:ublox}
\end{figure}

Die Übertragung der Daten des GNSS-Modules zum Laser\-scan\-ner erfolgt per serieller Schnittstelle über einen acht poligen Platinensteckverbinder. Da dieser Stecker jedoch unpraktisch war, wurde zusätzlich eine 3,5~mm Klinkenbuchse an der Schnittstellenbox des Laser\-scan\-ners montiert. Bei dem vom Laser\-scan\-ner benötigten Übertragungsprotokoll handelt es sich um das standardisierte NMEA-Protokoll, welches mit einer Datenrate von \(9600~\frac{bit}{s}\) und einer Signalspannung zwischen 3 und 15 Volt übertragen wird. Der direkte Anschluss des uBlox-GNSS-Modules brachte dennoch zunächst keinen Erfolg. Oszilloskop-ähnliche Messungen mit einem Arduino Mega 2560 (siehe \autoref{abb:oszi}) zeigten, dass das Signal des verwendeten GNSS-Moduls nicht dem im Datenblatt von \citet[S. 3]{vlpInterface} gefordertem entsprach. Es zeigte sich, dass das Signal gedreht werden musste, da die Definition der Signalspannung verschieden war: Der Laser\-scan\-ner benötigte ein Signal, bei dem Logisch 1 mit einer Spannung von über 3 Volt \citep[S. 3]{vlpInterface} entspricht (HIGH), bei dem GNSS-Modul entsprach die höhere Spannung Logisch 0.

\begin{figure}[!ht]
 \centering
 \includegraphics[width=0.7\textwidth]{img/oszi.png}
 % GNSS-Modul_Schaltplan_Entwurf.svg: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{Messung des Signals am uBlox NEO-6M (grün: Ausgangssignal; rot: Signal nach Nutzung eines Pegelwandler; 1000 Punkte entsprechen 5 Volt)}
 \label{abb:oszi}
\end{figure}

Um das Signal zu drehen wurde ein integrierter Schaltkreis 74HC04 verwendet. Hierbei handelt es sich um ein Logikkonverter, der die HIGH- und LOW-Signale (Signal gegen Masse) tauscht. Der Laser\-scan\-ner versorgt das GNSS-Modul mit 5 Volt Spannung, der GNSS-Chip benötigt jedoch eine Spannung von 3,3 Volt. Es wurde ein Spannungsregler verwendet, der die Spannung auf 3,3 Volt stabilisiert. Zur weiteren Stabilisierung wurden Kondensatoren eingesetzt. In Kombination mit dem Logikkonverter dient dieser auch als Pegelwandler. Die genaue Schaltung ist \autoref{abb:schaltplan} zu entnehmen.

\begin{figure}[!ht]
 \centering
 \includegraphics[width=0.8\textwidth]{img/schaltplanGnss.pdf}
 % GNSS-Modul_Schaltplan_Entwurf.svg: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{Entwurf der Schaltung zum Anschluss des GNSS-Modules an den Laser\-scan\-ner}
 \label{abb:schaltplan}
\end{figure}

\section{Steuerung im Betrieb}
\label{s:steuermodul}
Der Betrieb des Rasp\-berry Pi erfolgt ohne Tastatur und Bildschirm. Daher ist es notwendig, eine alternative Benutzerschnittstelle zu implementieren. Ein großer Steuerbedarf ist nicht gegeben, so dass wenige Tasten zum Stoppen der Datenaufzeichung und zum Herunterfahren des Rasp\-berry Pi ausreichend sind. Um auch eine Steuermöglichkeit zu implementieren, die im Flug genutzt werden kann, soll ein WLAN-Access-Point und ein simpler Webserver auf dem Rasp\-berry Pi implementiert werden, der den Zugriff zum Beispiel über ein Smartphone oder Laptop ermöglicht.

\begin{figure}[!ht]
 \centering
 \includegraphics[width=0.7\textwidth]{img/schaltplanRasp.pdf}
 % GNSS-Modul_Schaltplan_Entwurf.svg: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{Entwurf der Schaltung für die Steuerung des Rasp\-berry Pi}
 \label{abb:steuerung}
\end{figure}

\autoref{abb:steuerung} zeigt den Schaltplan des Steuermodules. Dieses bietet mit drei Leuchtdioden und 2 Tastern die Möglichkeit, im Skript später einfache Anzeigen und Eingaben zu realisieren. Hierfür wurde eine Erweiterung auf Basis des GPIO-Portes des Rasp\-berry Pi aufgebaut. Die zwei Taster sind über die beiden GPIO-Pins 18 und 25 erreichbar. Ohne Betätigung werden die Eingänge über die Pull-Up-Widerstände R4 und R6 auf ein High-Level gezogen. Durch Drücken des Tasters wird die Spannung über die Widerstände R5 und R7 auf ein Low-Level gezogen, welches durch das Pythonskript zur Laufzeit ausgelesen werden kann. Die Widerstände R5 und R7 dienen außerdem zur Strombegrenzung und als Sicherheit, falls die GPIO-Pins falsch geschaltet werden.
In der weiteren Optimierung der Schaltung wurden die externen Pull-Up-Widerstände (R4 und R6) durch die internen, softwaretrechnisch-schaltbaren Pull-Up-Widerstände des Raspberry Pi ersetzt. Dies ermöglicht auch die Nutzung des Raspberry Pi ohne angestecktes Steuermodul. Ansonsten könnten im Betrieb ohne Steuermodul auftretende Spannungsschwankungen fehlerhafterweise zu einer Erkennung als Tastendruck führen. Außerdem wurde die Funktion zum Starten und Stoppen auf zwei Taster verteilt, so dass hierfür ein dritter Taster verbaut wurde.
Die drei Leuchtdioden wurden mit jeweils einem 150 Ohm Vorwiderstand direkt zwischen einem GPIO-Pin und Ground eingebaut. Durch Ansteuerung der GPIO-Pins lassen sich diese An- und Abschalten. Außer zum Schutz und Betrieb der LEDs verhindern die Vorwiderstände auch eine zu hohe Stromaufnahme aus den GPIO-Pins. Die genaue Belastbarkeit der Pins ist nicht dokumentiert, jedoch wird meist von einem Wert um 10mA bei 3,3 Volt gesprochen \citep[zum Beispiel][]{ekRaspPin}. Alternativ, bei Nutzung leistungsstärkerer LEDs könnten diese auch unter Nutzung eines Transistors geschaltet werden. Diese ermöglichen es mit einem geringen Steuerungsstrom höhere Ströme zu schalten.

\begin{equation}
\begin{aligned}
U_R &= U_{GPIO} - U_{LED} = 3,3V - 2,0V = 1,3V    && \left|\  \text{Benötigter Spannungsabfall} \right. \\
R &= \frac{U_R}{I_{LED}} = \frac{1,3V}{0,01A} = 130\Omega   && \left|\  \text{min. Vorwiderstand} \right. \\
\end{aligned}
\label{eq:vorwiderstand}
\end{equation}

\section{Platinenentwurf und -realisierung}
Nach dem Entwurf und Test der beiden Schaltungen aus \autoref{abb:schaltplan} und \autoref{abb:steuerung} auf einem lötfreien Steckbrett, sollten diese Schaltungen zum späteren Einsatz an Bord des Multikopters als Platine mit verlöteten Bauteilen erstellt werden. Vorteil der gelöteten Schaltung ist ihre höhere Widerstandsfähigkeit gegen Vibrationen und Korrosion. Durch die Vibrationen im Flug könnten sich sonst die gesteckten Bauteile lösen und im schlimmsten Fall zum Kurzschluss und somit zur Zerstörung führen. Auch können die Kontakte zwischen den Federklemmen und den Bauteilen bei dem Betrieb außerhalb von Gebäuden durch Luftfeuchtigkeit korrodieren und somit der Kontaktwiderstand erhöht werden, was zu Störungen führen kann.

Für den Prototyp sollte die Schaltung von Hand aufgebaut und verlötet werden. Erst in der zukünftigen Entwicklung, wenn die Schaltung ausreichend erprobt wurde, könnte es sinnvoll sein, eine Platine ätzen zu lassen. Als Platine kommen daher vorerst nur vorgefertigte Layouts in Frage:

\begin{itemize}
 \item Lochrasterplatinen (Platine mit einzelnen Lötpunkten)
 \item Streifenrasterplatine (Lötpunkte sind in Streifen verbunden)
 \item Punktstreifenrasterplatine (Streifenrasterplatine, bei denen die Streifen regelmäßig, zum Beispiel alle 4 Lötpunkte, unterbrochen sind)
 \item spezielle Aufsteckplatinen für den Rasp\-berry Pi
\end{itemize}

Da nur wenige Bauteile benötigt wurden, wurde eine Streifenrasterplatine gewählt. Bei einer solchen Platine sind alle Kontakte in einer Reihe mit einer Leiterbahn verbunden. Falls keine Verbindung gewünscht ist, kann diese Leiterbahn mit einem Messer oder ähnlichem unterbrochen werden. Da das Unterbrechen der Leiterbahn jedoch zeitaufwändig und fehlerträchtig ist -- beispielsweise durch nicht vollständig getrennte Leiterbahnen -- sollten diese bei dem Layouten der Platine möglichst vermieden werden. Auch sollten möglichst viele der benötigten Verbindungen durch die Leiterbahnen erfolgen und möglichst wenige Drahtbrücken verwendet werden, die diese Leiterbahnreihen verbinden. Diese würden ansonsten zusätzlichen Lötaufwand erfordern. Das endgültige Layout der Platine ist der \autoref{abb:platine} zu entnehmen. Die fertige Platine ist auf der \autoref{abb:elektronik} zu sehen.

\begin{figure}[!ht]
 \centering
 \includegraphics[width=0.8\textwidth]{img/platine.pdf}
 \caption{Schematisches Layout der Lochstreifenplatine}
 \label{abb:platine}
\end{figure}

\begin{figure}[!ht]
 \centering
 \includegraphics[width=0.6\textwidth]{img/elektronik.jpg}
 \caption{Fertige Lochstreifenplatine aufgesteckt auf den Raspberry Pi}
 \label{abb:elektronik}
\end{figure}

Bei dem Routing wurden noch einige Teile der Schaltung optimiert und versucht einige Bauteile einzusparen. Es wurde zum Beispiel die Stromversorgung des Rasp\-berry Pi für den integrierten Schaltkreis und das GNSS-Modul verwendet, anstatt hierfür einen zusätzlichen Spannungswandler zu verwenden. Die Platinengröße wurde so gewählt, dass die Platine direkt auf den Rasp\-berry Pi 2 oder 3 aufgesteckt werden kann. Der endgültige Schaltplan ist \autoref{abb:gesamtschaltung} zu entnehmen. Für die Taster wurden hier die internen Pull-Up-Widerstände genutzt, so dass hier Widerstände eingespart werden konnten. Außerdem wurde der Datensendeport (Tx) vom GNSS-Modul an die serielle Schnittstelle des Rasp\-berry Pi angeschlossen, so dass der Rasp\-berry Pi nun auch ohne den Umweg über den Laser\-scan\-ner die Daten vom GNSS-Modul empfangen kann. Es wurde Platz für weitere LEDs oder Taster freigelassen.

\begin{figure}[!ht]
 \centering
 \includegraphics[width=0.8\textwidth]{img/schaltplanGesamt.pdf}
 \caption{Endgültiger Schaltplan}
 \label{abb:gesamtschaltung}
\end{figure}

\chapter{Theoretische Datenverarbeitung}
\label{c:datenverarbeitung}

\section{Verwendete Programmiersprachen}
\paragraph{Python}
Zur Realisierung der Programmierung wurde die Skriptsprache Python ausgewählt. Python bietet den Vorteil vergleichsweise kurzen und gut lesbaren Programmierstil zu fördern. Hierfür werden unter anderem nicht Klammern zur Bildung von Blöcken genutzt, sondern Texteinrückungen verpflichtend hierfür eingesetzt \citep[S. 13f]{python}. Die Struktur des Programms ist so schnell erfassbar. Außerdem ist es nicht notwendig, den Quellcode zu kompilieren. Er wird vom Interpreter direkt ausgeführt. Dies ermöglicht kurze Entwicklungszyklen ohne (zeit-)aufwändiges Kompilieren möglich. Änderungen und Anpassungen können schnell durchgeführt werden. Außerdem sind die Skripte größtenteils plattformunabhängig.

Python wurde in seiner ersten Version 1991 von Guido van Rossum veröffentlicht. Sein Ziel war es, eine einfach zu erlernende Programmiersprache zu entwickeln, die der Nachfolger der Sprache ABC werden sollte. Außerdem sollte die Sprache leicht erweiterbar sein und schon von Haus aus eine umfangreiche Standardbibliothek bieten. Python bietet mehrere Programmierparadigmen an, so dass je nach zu lösendem Problem objektorientiert oder strukturiert programmiert werden kann \citep[S. 14]{python}.

Die aktuelle Version von Python (Oktober 2017) ist die Version 3.6. Das Skript wurde unter Verwendung dieser Version entwickelt. Da sich viele Funktionen von der Version 2 zur 3 geändert haben, wurde auf die zuerst geplante Kompatibilität zu Python 2 verzichtet. Um Teile des Quellcodes als Python-Module auch in andere Skripte einfach einbinden zu können, aber auch den Quelltext übersichtlich zu halten, wurde der objektorientierte Programmierstil gewählt.

\paragraph{C++}
Ein großer Nachteil von Python ist die Ausführungsgeschwindigkeit. Daher wurden einzelne Teile des Quelltextes im Verlauf der Entwicklung in C++ umgeschrieben.
Bei C++ handelt es sich um eine objektorientierte Erweiterung der Programmiersprache C. C wurde 1972 von Dennis Ritchie entwickelt. Anfang der 1980er Jahre erweiterte Bjarne Stroustrup C zu C++. C++ hat zwar eine höhere Ausführungsgeschwindigkeit, dafür ist C++ jedoch nicht so leicht zu erlernen, wie zum Beispiel Python. \citep[S. 4f]{cpp}


\section{Datenlieferung des Laser\-scan\-ners}
\label{ss:Datenlieferung}
Der Laser\-scan\-ner Velodyne VLP-16 liefert seine Daten als UDP-Netzwerkpakete in einem proprietären, binären Datenformat. Diese Daten sind nicht direkt lesbar, sondern müssen vor einer weiteren Nutzung aufbereitet und umgeformt werden. Dies soll mittels des in dieser Arbeit entwickelten Skriptes durchgeführt werden.

Ein Datenpaket (siehe \autoref{tab:datenmodell}) besteht jeweils aus einem Header von 42 Bytes, gefolgt von 12 Datenblöcken mit jeweils 32 Messungen, abgeschlossen von 4 Bytes, die den Zeitstempel angeben und 2 Bytes, die den eingestellten Scan-Modus zurückliefern. Jeder Datenblock enthält die aktuelle horizontale Ausrichtung des rotierenden Lasers und darauf folgend die Messwerte von zwei Messungen der 16 Laserstrahlen. Die genaue Horizontalrichtung zum Zeitpunkt der Messung muss aus den Horizontalrichtungen von zwei auf einander folgenden Messungen interpoliert werden.

\begin{table}[!ht]
\centering
\begin{tabular}{|lll|l|l|}
\hline
Header                                         &                                 
                &           & Netzwerk-Header  & 42 Bytes \\ \hline
\multicolumn{1}{|l|}{\multirow{7}{*}{Block 1}} &                                 
                & 0-1       & Flag             & 2 Bytes  \\ \cline{2-5} 
\multicolumn{1}{|l|}{}                         &                                 
                & 2-3       & Horizontalrichtung & 2 Bytes  \\ \cline{2-5} 
\multicolumn{1}{|l|}{}                         & 
\multicolumn{1}{l|}{\multirow{2}{*}{Messung 1}} & 4-5       & Entfernung       & 
2 Bytes  \\ \cline{3-5} 
\multicolumn{1}{|l|}{}                         & \multicolumn{1}{l|}{}           
                & 6         & Reflektivität    & 1 Byte   \\ \cline{2-5} 
\multicolumn{1}{|l|}{}                         & 
\multicolumn{1}{l|}{\multirow{2}{*}{Messung 2}} & 7-8       & Entfernung       & 
2 Bytes  \\ \cline{3-5} 
\multicolumn{1}{|l|}{}                         & \multicolumn{1}{l|}{}           
                & 9         & Reflektivtät     & 1 Byte   \\ \cline{2-5} 
\multicolumn{1}{|l|}{}                         & \multicolumn{4}{l|}{Messungen 3 
- 32}                                                     \\ \hline
\multicolumn{5}{|l|}{Block 2 - 12}                                               
                                                          \\ \hline
Time                                           & \multicolumn{1}{l|}{}           
                & 1200-1204 & Zeitstempel      & 4 Bytes  \\ \hline
Factory                                        & \multicolumn{1}{l|}{}           
                & 1205-1206 & Return-Modus     & 2 Bytes  \\ \hline
\end{tabular}

\caption{Aufbau der Daten des Netzwerkpaketes, nach \citet[S. 12]{vlpManual}}
\label{tab:datenmodell}
\end{table}

Der Laser\-scan\-ner sendet bei der Einstellung Dual Return, also der Rückgabe vom stärksten und letzten Echos pro Messung 
bis zu 1508 Pakete dieser Form pro Sekunde \citep[S. 49]{vlpManual}. Die Ausgangsdaten werden, bei einer Paketgröße von 1248 Bytes mit einer Datenrate von 1,8 MB/s empfangen (siehe \autoref{equ:Ausgangsrate}). Hierbei werden fast 600.000 Messwerte pro Sekunde übertragen (siehe \autoref{equ:MessungenPS}).

\begin{equation}
1~508~\frac{\text{Pakete}}{\text{Sekunde}}~\cdot~12~\frac{\text{Datenbl\"{o}cke}}{\text{Paket}}~\cdot~
32~\frac{\text{Messungen}}{\text{Datenblock}}~=~579~072~\frac{\text{Datens\"{a}tze}}{\text{Sekunde}}
 \label{equ:MessungenPS}
\end{equation}

\begin{equation}
1~508~\frac{\text{Pakete}}{\text{Sekunde}}~\cdot~1~248~\frac{\text{Bytes}}{\text{Paket}}~=~1,79~\text{MB/s}
 \label{equ:Ausgangsrate}
\end{equation}

\section{Geplantes Datenmodell}
\label{s:datenmodell}
Die Daten des Laser\-scan\-ners sollen in einer einfach lesbaren Textdatei abgelegt werden. In der Nachbereitung sollen die Daten aus dieser Textdatei mit den Daten der inertialen Messeinheit und des GNSS-Empfängers verknüpft werden, um so die Daten georeferenzieren zu können. Als Verknüpfung bietet sich hier der Zeitstempel an. Die inertiale Messeinheit und der Laser\-scan\-ner können hierbei die Zeitdaten aus dem GNSS-Signal verwenden. Hierdurch sind hochgenaue Zeitstempel möglich. Die Zeitinformation bildet also einen wichtigen Schlüssel in den Daten. Als einfaches Textformat wurden durch Tabulator getrennte Daten, jeweils eine Zeile je Messung, gewählt. Folgende Daten sind in dieser Reihenfolge enthalten:

\begin{itemize}
 \item Zeitstempel in Mikrosekunden
 \item Richtung der Messung in der Rotationsebene in Grad
 \item Höhenwinkel zur Rotationsebene in Grad
 \item Gemessene Entfernung in Metern
 \item Reflektivität auf einer Skala von 0 bis 255
\end{itemize}

Problematisch ist bei diesem Datenmodell jedoch die benötigte Datenrate. Eine Datenzeile erfordert 29 Bytes und somit wird bei über einer halben Million Messungen pro Sekunde (siehe \autoref{equ:MessungenPS}) eine Datenschreibrate von mindestens 16 MB/s benötigt (siehe \autoref{equ:Datenrate}). Da das Schreiben nicht dauerhaft erfolgt, sollte die Datenrate bevorzugt deutlich höher sein.

\begin{equation}
579~072~\frac{\text{Datens\"{a}tze}}{\text{Sekunde}}~\cdot~29~\frac{\text{Bytes}}{\text{Datenzeile}}~=~16,02~\text{MB/s}
\label{equ:Datenrate}
\end{equation}

Erste Tests ergaben, dass diese Verarbeitungsgeschwindigkeit nicht mit dem Rasp\-berry Pi erreicht werden konnte. Außerdem benötigen die Daten sehr viel Speicher. Daher wurde sich später für eine Hybridlösung entschieden (siehe \autoref{c:skript}).

\section{Weiterverarbeitung der Daten zu Koordinaten}
Die als Text gespeicherten Rohdaten sollen dann im Rahmen einer weiterführenden Arbeit zu Koordinaten umgewandelt werden. Zu dieser Umwandlung werden die Daten des GNSS-Empfänger und der IMU verwendet, um eine Trajektorie zu berechnen. Aus der Trajektorie kann dann die Position und die Ausrichtung des Laser\-scan\-ers für jeden Messzeitpunkt bestimmt werden und auf die Messdaten angewandt werden, um hieraus eine Koordinate im übergeordneten System zu bestimmen.

Bei der Berechnung ist jedoch zu beachten, dass der Ursprungsort der Entfernungsmessung zwar in der Drehachse des Laser\-scan\-ners liegt, jedoch der Schnittpunkt der ausgesendeten Strahlen etwa 40mm in Strahlrichtung verschoben ist (siehe \autoref{img:strahlengang}). Bei der Streckenberechnung ist diese Strecke mit enthalten, jedoch kann zur Berechnung der Z-Komponente der lokalen Koordinaten nicht einfach der Höhenwinkel und die gemessene Strecke verwendet werden. Die lokalen Koordinaten berechnen sich somit nach der \autoref{equ:koordinaten}.

\begin{figure}[!ht]
 \centering
 \includegraphics[width=0.7\textwidth]{./img/Strahlengang.png}
 % Strahlengang.eps: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=0 0 3066 4000
 \caption{Strahlengang im Laser\-scan\-ner VLP-16, Werte in Millimetern, nach 
\citet{vlpCAD}}
 \label{img:strahlengang}
\end{figure}

\begin{equation}
\begin{aligned}
h:&~\text{H\"{o}henwinkel}~(-15^\circ - 15^\circ) \\
r:&~\text{Horizontalrichtung}~(0^\circ - 360^\circ) \\
s:&~\text{Gemessene~Strecke} \\
\\
s_S &= s - 41,91~mm    		 && \left|\  \text{Schr\"{a}gstrecke nach dem Fokuspunkt} \right. \\
s_H &= s_S \cdot \cos(h) + 41,91~mm  && \left|\  \text{Horizontalstrecke von der Drehachse} \right. \\
\\
X &= s_H \cdot \sin(r) && \left|\  \text{Y-Achse in Nullrichtung} \right. \\
Y &= s_H \cdot \cos(r) \\
Z &= s_S \cdot \sin(h) \\
\end{aligned}
\label{equ:koordinaten}
\end{equation}

\section{Anforderungen an das Skript}
\label{s:anforderungen}
Aus den technischen Vorgaben ergeben sich dann folgende Funktionen, die das Skript aufweisen muss:
\begin{itemize}
 \item Rohdaten vom Scanner abrufen
 \item Zeit vom GNSS-Modul abrufen
 \item Steuerungmöglichkeit mittels Hard- und Software
 \item Umwandlung in eigenes Datenmodell
\end{itemize}

Der Ablauf ist oft abhängig vom Fortschritt anderer Schritte und Voraussetzungen. Daher wurden die benötigten, einzelnen Schritte vorerst als grober Ablaufplan skizziert. So hat der Rasp\-berry Pi keinen eigenen Zeitgeber. Um die Dateien aber mit dem korrekten Zeitstempel zu versehen, ist daher eine aktuelle Uhrzeit notwendig - diese liefert das GNSS-Modul, welches am Laser\-scan\-ner angeschlossen ist, sofern ein GNSS-Fix besteht. Es muss also, vor dem Erzeugen der Dateien, auf ein gültiges GNSS-Signal gewartet werden. Der endgültige, vereinfachte Ablaufplan ist der \autoref{img:ablaufplan} zu entnehmen. 
\begin{figure}[!ht]
 \centering
 \includegraphics[width=1\textwidth]{./img/ablaufplan.pdf}
 % Strahlengang.eps: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=0 0 3066 4000
 \caption{Vereinfachter Ablaufplan des Skriptes}
 \label{img:ablaufplan}
\end{figure}

\chapter{Entwicklung des Skriptes}
\label{c:skript}

Die Entwicklung des Skriptes bzw. des Programmes erfolgte iterativ-inkrementell. Bei diesem Vorgehensmodell, welches stark mit der agilen Entwicklung verknüpft ist, wird anfangs nur eine grobes Anforderungsprofil (siehe \autoref{s:anforderungen}) festgelegt. Es werden regelmäßig Prototypen erstellt und geprüft. Bei dieser Prüfung werden neue Anforderungen gesammelt beziehungsweise bestehende konkretisiert. So ist am Anfang der Entwicklung noch nicht klar, wie das Produkt am Ende aussehen wird und welchen Funktionsumfang dieses hat. Vorteil dieser Entwicklung ist es, dass schnell funktionsfähige Prototypen ermöglicht werden und auch durch den Auftraggeber, in diesem Fall die Betreuer, ständig Einfluss auf die Funktion und die Bedienung der Software möglich ist. \citep[S. 33f]{uml}

Zur Unterstützung der Programmierung wurden vorallem die Lehrbücher \textit{Einstieg in Python} \citep{python}, \textit{Python 3 Object-oriented Programming} \citep{python3oop}, \textit{Learning Flask Framework} \citep{flask} und \textit{C/C++ für Studium und Beruf} \citep{cpp} verwendet.

\section{Klassenentwurf}
Da das Skript objektorientiert programmiert werden soll, wurden zunächst mit Hilfe der anfangs bekannten Anforderungen und dem Ablaufplanes aus \autoref{img:ablaufplan} die benötigten, grundlegenden Klassen entworfen. Durch die Erweiterungen und die übliche Refaktorisierung -- der ständigen Optimierung des Quellcodes in seiner Lesbarkeit und Geschwindigkeit \citep[S. 255]{uml} -- erweiterte sich dieses Modell zu dem endgültigen Klassen der \autoref{img:uml}. Auf die genauen Funktionen der einzelnen Klassen wird im \autoref{s:klassen} eingegangen.


\begin{figure}[!ht]
 \centering
 \includegraphics[width=1\textwidth]{./img/UML.pdf}
 % Strahlengang.eps: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=0 0 3066 4000
 \caption{UML-Klassendiagramm}
 \label{img:uml}
\end{figure}

\section{Evaluation einzelner Methoden}
Um eine einfache Fehlersuche zu ermöglichen, wurden die grundlegenden Funktionen in einzelnen Skripten entwickelt und geprüft. Diese kleineren Skripte haben den Vorteil, dass Fehler schneller eingegrenzt und auch schon früh konzeptionelle Fehler entdeckt werden können. In diesem Schritt wurde bemerkt, dass die Geschwindigkeit der Datenverarbeitung ein großes Problem darstellt. 

\paragraph{Datenempfang}
Die Verbindung zum Laser\-scan\-ner mittels Python-Socket funktionierte ohne weitere Probleme. Die binären Daten konnten zeitgleich abgespeichert werden.

\paragraph{Datentransformation}
Zunächst war es geplant, die Daten direkt in das in \autoref{s:datenmodell} vorgestellte Datenmodell umzuformen. Hierzu sollte der Empfang der Daten direkt eine Umformmethode starten. Die Versuche erfolgten zunächst mit dem im vorherigen Test aufgezeichneten Daten. Schon hier zeigte sich, dass die Umwandlung der aufgezeichneten Daten etwa das Fünffache der Mess- und Aufzeichnungzeit beanspruchte. Wie erwartet, brachte auch das direkte Einlesen der Daten vom Scanner keinen Erfolg. Es folgte ein Überlauf des Netzwerk-Buffers und somit der Verlust von Messdaten. Grund hierfür war hauptsächlich die benötigte Prozessorzeit. Die Nutzung einer schnelleren Datenspeicherung auf einer Solid-State-Disk mit einer Schreibrate von bis zu 300 MB/Sekunde änderte nichts an der Geschwindigkeit des Skriptes. Auch das Erzeugen eines neuen Threads für jeden empfangenen Datensatz war nicht erfolgsversprechend, da bis zu 1500 Threads pro Sekunde hierdurch gestartet wurden und das gesamte System überlastet wurde. Die Umformung musste daher von dem Datenempfang entkoppelt werden und das Skript für die Nutzung von Mehrkernprozessoren optimiert werden. Threads in Python laufen dennoch in einem Prozess und somit nur auf einem Prozessor. Es wurde das in \autoref{s:multikern} vorgestellte Multikern-Konzept erarbeitet.

\paragraph{Hardware-Steuerung}
Ein Tastendruck auf dem Steuerungsmodul (siehe \autoref{s:steuermodul}) sollte den Rasp\-berry Pi zum Beispiel herunterfahren. Auch dieses Skript wurde getestet. Ein Problem hierbei war es, dass das Skript Administratorrechte (\code{root}) benötigte, um den Rechner herunterfahren zu können. Hierfür wurde jedoch eine Lösung gefunden, indem dem Nutzer \code{pi} die entsprechenden Rechte zum Herunterfahren gegeben wurden (siehe \autoref{s:root}). Eher zufällig zeigte sich aber noch ein anderes Problem: Sofern das Skript automatisch mit dem Start des Rasp\-berry Pi gestartet wurde und das Steuermodul nicht angeschlossen war, fuhr der Rasp\-berry Pi automatisch nach wenigen Sekunden Betrieb herunter. Da mit dem fehlenden Modul auch die Pull-Up-Widerstände fehlten, war der GPIO-Pin auf einem nicht definierten Zustand. Es kam dazu, dass er zufällig auf einem HIGH-Niveau war, welches als Drücken des Tasters interpretiert wurde. Nach Überschreiten der konfigurierten Haltezeit des Ausschalters von zwei Sekunden, wurde der Herunterfahrprozess gestartet. Um dieses Problem zu unterdrücken, wurde dem Skript zuerst eine vorherige Abfrage hinzugefügt, die bei dem Start überprüft, ob die beiden Taster sich auf einem High-Niveau befinden, dass durch die beiden angeschlossenen Pull-Up-Widerstände erreicht wird. Falls dieses nicht der Fall ist, beendet sich die Hardwaresteuerung selbst\-stän\-dig. Im weiteren Verlauf der Entwicklung wurden die internen Pull-Up-Widerstände des Rasp\-berry Pi verwendet. Somit wurde diese Abfrage überflüssig.

\paragraph{Steuerung}
Die grundlegenden Einstellungen erfolgen über die Konfigurationsdatei \code{config.ini}. Hier können Einstellungen zum Verhalten des Skript durchgeführt werden, aber auch die Parameter des Laser\-scan\-ners angepasst werden. Die weitere Steuerung erfolgt über die Weboberfläche des Skriptes und des Laser\-scan\-ners.

\section{Multikern-Verarbeitung der Daten}
\label{s:multikern}
Da bei der Evaluation der einzelnen Methoden herausgefunden wurde, dass die Verarbeitungsgeschwindigkeit des Rasp\-berry Pi für eine sofortige Transformation der Daten nach deren Eingang zu langsam ist, wurde ein Konzept erarbeitet, den hierdurch auftretenden Messdatenverlust zu unterdrücken.

Der Verarbeitung musste ein weiterer Buffer vorgeschaltet werden. Das plötzliche Abschalten des Rasp\-berry Pi, zum Beispiel durch einen Verlust der Energieversorgung, sollte jedoch nicht zu Datenverlusten führen. Es konnte daher nicht die in Python integrierten Funktionen zur Datenzwischenspeicherung verwendet werden -- diese nutzen zur Zwischenspeicherung auf den Arbeitsspeicher, der durch Stromverlust gelöscht wird. Das dauerhafte Schreiben auf die Festplatte -- im Fall des Rasp\-berry Pi einer MicroSD-Speicherkarte -- führt aber zur weiteren Verzögerung. Es wurde daher eine Hybridlösung erarbeitet.

Die Arbeit wird nun auf mehrere Prozesse verteilt:
\begin{itemize}
 \item Start des Skriptes und Gesamtsteuerung in einem Prozess mit mittlerer Priorität (Klasse \code{VdAutoStart}, mit Threads für die Weboberfläche (Methode \code{startWeb()} in der Klasse \code{VdAutoStart}) und Hardwaresteuerung (Klasse \code{VdHardware})
 \item Sammeln der Daten in einem Prozess mit höchster Priorität (Klasse \code{VdBuffer})
 \item Umformen der Daten durch mehrere Prozesse je nach Prozessorkernanzahl mit erhöhter Priorität (Klasse \code{VdTransformer})
\end{itemize}

Die Daten werden nun zuerst für wenige Sekunden im Arbeitsspeicher gesammelt. Sobald eine in der Konfiguration festgelegte Anzahl von Datensätzen zwischengespeichert wurde, werden diese im Dateisystem als binäre Datei abgelegt und der Dateiname in einer Warteschlange aus dem \code{multiprocessing}-Modul von Python (Klasse \code{Queue}) abgelegt. Die Prozesse zum Umformen der Daten fragen diese Warteschlange nun ab, verarbeiten jeweils eine binäre Datei und hängen die Ergebnisse an eine Ergebnis-Textdatei an. Die Dateinamen der binären Dateien, dessen Bearbeitung begonnen wurde, werden aus der Warteschlange entfernt. Nach dem Schreiben der umgeformten Daten werden die binären Dateien aus dem Dateisystem entfernt (abschaltbar). Damit die Umformer-Prozesse bei dem Schreiben nicht auf einander warten müssen, schreibt jeder Prozess in eine andere Ergebnisdatei. Diese können nach der Messung einfach zusammengefügt werden. Falls nun zum Beispiel die Stromversorgung unterbrochen wird, sind nun nur die Daten der letzten Sekunden verloren. Ältere Daten sind auch trotz Spannungsverlust als binäre Daten oder als Textdatei gespeichert. Durch ein Konverierungsskript ist es im Nachhinein möglich, den Umformerprozesses alleine zu starten und die restlichen, noch nicht umgewandelten Daten umzuformen.

Durch dieses Prinzip stört eine stockende Datenumformung nicht die Aufzeichnung der Daten vom Scanner. Sofern der Rasp\-berry Pi nicht die Geschwindigkeit der Umformung halten kann, werden einfach mehr binäre Dateien zwischengespeichert, welche gegebenenfalls im Postprocessing umgewandelt werden können.

\section{Auslagerung der Transformation in C++}
Da auch bei Nutzung der kompletten Prozessorleistung des Rasp\-berry Pi es nicht möglich war, die Daten zeitgleich zu transformieren und lange Nachbearbeitungszeiten auftraten, wurden weitere Ansätze geprüft. Am erfolgsversprechendsten war die Nutzung von C++ für diesen Teil. Die Programmiersprachen C und C++ sind bekannt dafür, dass sie sehr schnelle Ausführungszeiten bieten. Die Klassen, welche für die Transformation zuständig waren, wurden daher in C++ nachgebaut. Die Geschwindigkeit für die Umformung eines Testdatensatzes erfolgte in etwa der zehnfachen Geschwindigkeit. Diese Steigerung reicht aus, um bei Nutzung der vier Kerne des Rasp\-berry Pi die Daten zeitgleich umzuformen. Der C++-Code wurde als eigenständiges Kommandozeilenprogramm erstellt. Somit ist es unabhängig vom Python-Code und kann auch selbständig verwendet werden, zum Beispiel zum späteren Umformen von Daten.
Die Pythonklasse \code{VdTransformer} wurde so erweitert, dass sie das zusätzlichen C++Programmes zur Umformung verwenden kann. Mit den Einstellungen in der Konfigurationsdatei kann gegebenenfalls auch auf die Nutzung der Pythonskripte umgeschaltet werden. So kann je nach verwendeter Umgebung zwischen der Umformung mittels Python (plattformunabhängig) und den für verschiedene Plattformen kompilierten C++-Umformungen (ARM 32bit, Linux 64bit) gewechselt werden.

\section{Klassen}
\label{s:klassen}

\subsection{VdAutoStart (Python)}
Die Klasse \code{VdAutoStart} (siehe Anhang~\ref{a:vdAutoStart.py}) steuert den automatischen Start des Skriptes bei dem Hochfahren des Rasp\-berry Pi. Sie ist verantwortlich für den korrekten Start der einzelnen Skriptteile in der richtigen Reihenfolge. Außerdem sind in der zugehörigen Datei auch alle Programmteile abgelegt die nicht zu einer Klasse gehören wie zum Beispiel der Startaufruf und das Webinterface.

\paragraph{Flask-Webinterface app}
Die Weboberfläche zur Steuerung wird mit dem Modul \code{Flask} erzeugt. Die Weboberfläche wird durch die main-Methode in einem zusätzlichen Thread gestartet. Die Weboberfläche ist entsprechend ihrem geplanten Einsatzzweck optimiert für die mobile Anzeige auf Smartphones, lässt sich aber auch vom Laptop bedienen. Die Oberfläche selbst nutzt nur HTML und CSS - ist also nicht zusätzlichen Skriptsprachen auf dem verwendeten Gerät abhängig. 
Sie ermöglicht den Start und den Stop der Datenaufnahme, das Übertragen der aufgezeichneten Daten und das Herunterfahren des Raspberry Pi.

\subsection{VdInterface (Python)}
Die Klasse \code{VdInterface} (siehe Anhang~\ref{a:vdInterface.py}) übernimmt die Kommunikation mit dem Laser\-scan\-ner. Sie stellt die UDP-Socket-Verbindungen zu dem GNSS- und zu dem Laserscan-Datenstream des Scanners her.


\subsection{VdHardware (Python)}
Die Klasse \code{VdHardware} übernimmt die Hardwaresteuerung des Rasp\-berry Pi. Um etwas unabhängiger zu sein, stellt die Klasse einen eigenen Thread dar, der von der Klasse \code{VdAutoStart} je nach Hardware gestartet wird. Hierdurch werden die Abläufe des Hauptskriptes nicht durch die Abfrageschleifen der Hardwaresteuerung unterbrochen.

Bei der Initialisierung der Klasse werden die GPIO-Ports des Rasp\-berry Pi entsprechend des Hardwaresteuerungsmodules aus \autoref{s:steuermodul} eingerichtet. Hierbei werden bei den Eingangsports die internen Pull-Up-Widerstände aktiviert. Bei dem Start des Threads wird dann zusätzlich ein Eventhandler für die Eingangspins eingerichtet, der entsprechende Funktionen zum Starten oder Stoppen der Aufzeichnung sowie zum Herunterfahren aufruft. Desweiteren wird ein Timer aktiviert, der dafür sorgt, dass die Status-LEDs (siehe \autoref{abb:elektronik}) einmal sekündlich aktualisiert werden.

\subsection{VdPoint (Python / C++)}
Die \code{VdPoint}-Klasse stellt einen Messpunkt der Velodyne dar. Er nimmt als Attribute die Messdaten auf. Außerdem bietet die Klasse die Möglichkeit, die Messdaten in lokale kartesische Koordinaten mit dem Laser\-scan\-ner als Ursprung umzurechnen. Dieses wird zum Beispiel bei der Erzeugung von OBJ- und XYZ-Dateien genutzt.

\subsection{VdDataset (Python / C++)}
Die Klasse \code{VdDataset} nimmt die Messdaten auf. Diese Klasse sorgt auch für das Interpretieren der binären Daten vom Laser\-scan\-ner. Die Daten werden dann als \code{VdPoint}-Objekte in einer Liste gesichert. Durch die Übergabe der Daten an die Implementierungen der Klasse \code{VdFile} können diese dann als Datei gespeichert werden.

\subsection{VdFile und Subklassen (Python / C++)}
Bei der Klasse \code{VdFile} handelt es sich um eine abstrakte Klasse. Die Klasse stellt ein Interface bereit, das die Speicherung der umgewandelten Daten übernimmt. Die genauen Datenformate werden in Klassen festgelegt, die von ihr erben:

\paragraph{VdASCIIFile sowie VdTxtFile, VdObjFile und VdXYZFile}
Die abstrakte Klasse \code{VdASCIIFile} erweitert die Klasse \code{VdFile} um Funktionen, um ASCII-Dateien zu schreiben. \code{VdTxtFile} und \code{VdObjFile} implementieren dann die eigentlichen Dateiformate. Die Klasse \code{VdTxtFile} schreibt hierbei die Rohdaten als einfache Textdateien. \code{VdObjFile} formt die Rohdaten in lokale Koordinaten mit dem Ursprung im Standpunkt des Scanners um und speichert die Daten als OBJ-Datei. Das Dateiformat ist für das einfache Betrachten der Daten hilfreich. Es lässt sich als Punktwolke in vielen Programmen, wie zum Beispiel \code{MeshLab}, einlesen und darstellen. Im Zusammenhang mit der Vergleichsmessung aus \autoref{c:systemueberpruefung} wurde zusätzlich noch eine Klasse zur Implementierung von XYZ-Dateien (\code{VdXYZFile}) erstellt. Hier werden die schon für die OBJ-Dateien aufbereiteten Daten in anderer Formatierung genutzt.

\paragraph{VdSQLite}
Die Klasse \code{VdSQLite} ermöglicht das Speichern der Rohdaten in einer SQLite-Datenbank-Datei. Das Format bietet sich zum einfachen Übertragen und Auswerten der Daten an. Alle Daten werden in einer Datenbank-Datei gesichert. Dies erleichtert das Einladen der Daten in weitere Skripte, zum Beispiel zum Durchführen von Berechnungen.

\subsection{VdBuffer}
Die Klasse \code{VdBuffer} übernimmt die Zwischenspeicherung der binären Rohdaten vom Laser\-scan\-ner. Über die Klasse \code{VdInterface} wird eine Socketverbindung zum UDP-Port des Laser\-scan\-ners hergestellt. Anschließend werden die Daten vom Socket in einer Variable gespeichert und regelmäßig in kurzen Intervallen als bin-Datei auf dem Speicher des Rasp\-berry Pi abgelegt. Hierzu wird bei dem ersten Datenempfang ein Verzeichnis für die Messung angelegt. Nach dem Schreiben der Datei wird ihr Pfad in die Warteschleife für \code{VdTransformer} eingetragen.

\subsection{VdTransformer}
\code{VdTransformer} übernimmt die Umformung der als Datei gespeicherten binären Daten in \code{VdPoint}-Objekte. Um die Leistung des jeweiligen Computersystems auszunutzen, wird durch \code{VdAutoStart} die Anzahl der Instanzen des Prozesses je nach Anzahl der Kerne des Prozessors gesteuert -- auf dem Rasp\-berry Pi als Vierkern-System beispielsweise drei Prozesse. Sofern die Daten als ASCII-File gesichert werden sollen, wird für jede Instanz eine Datei erstellt, damit sich die Schreibprozesse nicht gegenseitig stören. Aus der Warteschlange wird jeweils eine binäre Datei ausgewählt, eingelesen und an ein Objekt der Klasse \code{VdDataset} übermittelt. Nachdem dieses die Daten zu einer Liste von \code{VdPoint}-Objekten umgewandelt hat, werden diese Daten an ein Objekt der Klasse \code{VdFile} übergeben. Dieses schreibt dann je nach Einstellung in der Konfigurationsdatei die Daten im gewünschten Dateiformat. Nach dem erfolgreichen Schreibvorgang, wird die bin-Datei gelöscht (oder je nach Einstellungen verschoben).

\chapter{Konfiguration des Rasp\-berry Pi}
\label{c:konfig}

Als Grundlage wurde auf die MicroSD-Karte, die dem Rasp\-berry Pi als Festplatte dient, das Betriebssystem Raspbian aufgespielt. Hierbei handelt es sich um ein Derivat von Debian GNU/Linux, das speziell auf die Hardware des Rasp\-berry Pi angepasst ist. Die aktuelle Version (Stand 10.12.2017) nennt sich Raspian Stretch. Für die Verwendung als Verarbeitungsgerät ohne angeschlossenen Display reicht die Variante ohne grafische Benutzeroberfläche aus (Raspbian Stretch Lite). Die Konfiguration des Rasp\-berry Pi erfolgt vollständig über Konfigurationsdateien. In dieser Arbeit erfolgte die Konfiguration per Fernzugriff über SSH, einem Standard für das Fernsteuern der Konsole über das Netzwerk. Eine Konfiguration hätte aber auch mittels einem angeschlossenen Display und einer USB-Tastatur erfolgen können.

Die Änderungen der Konfigurationsdateien erfolgten mit dem vorinstallierten Editor \code{nano} unter Nutzung von Administratorrechten. Ein solcher Aufruf erfolgt zum Beispiel mit dem Befehl \code{sudo nano /pfad/zur/konfiguration.txt}. Nachfolgend müssen die betroffenen Programme oder sogar das komplette Betriebssystem neu gestartet werden. Der Neustart eines Services erfolgt zum Beispiel mit dem Aufruf \code{sudo service programmname restart}, der Neustart des Betriebssystems mit \code{sudo shutdown -r now}. Es empfiehlt sich, von allen zu ändernden Konfigurationsdateien Sicherungskopien anzulegen. Dies erfolgt zum Beispiel mit \code{sudo cp original.txt original.old.txt} (Kopieren) oder \code{sudo mv original.txt original.old.txt} (Verschieben, zum Beispiel zum Anlegen einer komplett neuen Datei). Auf diese Linux-Grundlagen wird im Folgenden nicht mehr eingegangen.

\section{Installation von Raspbian}
Die Installation von Raspbian erfolgt durch das Entpacken des Installationspaketes von der Website der Rasp\-berry Pi Foundation auf einer leeren MicroSD-Karte mit dem Tool \code{Etcher}. Auf der nach dem Entpacken erzeugten boot-Partition wird eine leere Datei mit dem Namen \code{ssh} angelegt. Hierdurch wird sofort nach dem Start der SSH-Zugang über das Netzwerk zum Rasp\-berry Pi ermöglicht, die IP-Adresse wird per DHCP, zum Beispiel von einem im Netzwerk vorhandenen Router, bezogen. Nach dem Login, unter Linux mit dem Befehl \code{ssh pi@raspberrypi}, kann mittels \code{passwd} das Passwort verändert werden. Mit den Befehlen \code{sudo rpi-update}, \code{sudo apt update}, \code{sudo apt upgrade} und \code{sudo apt upgrade} wird die Firmware und das Betriebssystem auf den neusten Stand gebracht. Mit \code{sudo apt-get install python3-pip} wird der Paketmanager von Python 3 installiert. Er ermöglicht das einfache Installieren von zusätzlichen Modulen. Die benötigten Pakete werden mit \code{pip3 install flask pyserial RPi.GPIO} installiert. Falls der Rasp\-berry Pi auch mit der Tastatur gesteuert werden können soll, bietet es sich an, die Lokalisation einzurichten im Konfigurationsmenü unter \code{sudo raspi-config}. Außerdem muss mit diesem Tool das Warten auf die Netzwerkverbindung bei dem Systemstart und die Nutzung der seriellen Schnittstelle als Ausgabe der Eingabekonsole deaktiviert werden.

% HafenCity

\section{Befehle mit Root-Rechten}
\label{s:root}
Linux erlaubt das Ändern der Zeit und das Herunterfahren über die Kommandozeile nur dem Administrator (\code{root}). Da es jedoch nicht empfohlen ist, Skripte als \code{root} auszuführen, muss hier eine andere Lösung gefunden werden, um den Skripten die Möglichkeit zu geben, den Rasp\-berry Pi auf Tastendruck oder per Web-Steuerung herunterzufahren. Hierfür wurden dem normalen Nutzer (\code{pi}) die Rechte gegeben, einzelne Befehle  als Administrator ohne Passwortabfrage auszuführen. Diese Rechte können dem Nutzer durch das Eintragung in der Konfigurationsdatei \code{/etc/sudoers} gegeben werden. Da eine fehlerhafte Änderung der Datei den kompletten Administratorzugang zum System versperren kann, wird die Datei mit dem Befehl \code{sudo visudo -f /etc/sudoers} überarbeitet, der nach dem Editieren die Datei auf Fehler prüft. Die zusätzlichen Einträge in der Konfiguration sind dem \autoref{Lsudoers} zu entnehmen.\citep[S. 33]{Frisch2003}

\begin{lstlisting}[caption={Ergänzung der \code{/etc/sudoers}}, label={Lsudoers}]
# Cmnd alias specification
Cmnd_Alias VLP = /sbin/shutdown, /sbin/date

# User privilege specification
pi	ALL=(ALL) NOPASSWD: VLP
\end{lstlisting}

\section{IP-Adressen-Konfiguration}
Die Ethernet-Schnittstelle des Rasp\-berry Pi soll die IP-Adresse \code{192.168.1.111} nutzen werden, da diese IP-Adresse im Laser\-scan\-ner als Host eingestellt war und an diesen die Daten vom Scanner übertragen werden. Die IP-Adresse des Rasp\-berry Pi im WLAN wurde fest auf die gut zu merkende Adresse \code{10.10.10.10} geändert, hierüber erfolgt später der Zugriff auf die Weboberfläche (siehe auch \autoref{tab:ipAdressen}).

\begin{table}[!ht]
\centering
\begin{tabular}{l|r|r|l|}
\cline{2-4}
                                                    & Schnittstelle & \multicolumn{2}{c|}{IP-Adresse bzw. Bereich} \\ \hline
\multicolumn{1}{|l|}{Laser\-scan\-ner}                  & Ethernet      & 192.168.1.111        & statisch              \\ \hline
\multicolumn{1}{|l|}{\multirow{2}{*}{Rasp\-berry Pi}} & Ethernet      & 192.168.2.110        & statisch              \\ \cline{2-4} 
\multicolumn{1}{|l|}{}                              & WiFi          & 10.10.10.10          & statisch              \\ \hline
\multicolumn{1}{|l|}{Client}                        & WiFi          & 10.10.10.100         & - 10.10.10.254        \\ \hline
\end{tabular}
\caption{IP-Adressen-Verteilung}
\label{tab:ipAdressen}
\end{table}

Die Konfiguration der IP-Adressen für den Rasp\-berry Pi erfolgt in der Konfigurationsdatei \code{/etc/network/interfaces} (siehe \autoref{interfaces}). Um zukünftige Updates einfach zu ermöglichen, müssen die statischen IP-Einstellungen (Zeile 8-11) im Normalfall abgeschaltet werden und die DHCP Einstellungen (Zeile 13) aktiviert werden. \citep{accesspoint}

\begin{lstlisting}[caption={Konfiguration der \code{/etc/network/interfaces}}, label={interfaces}]
#localhost
auto lo
iface lo inet loopback

#Ethernet
auto eth0
## for Velodyne
iface eth0 inet static
	address 192.168.1.110
	netmask 255.255.255.0
	gateway 192.168.1.110
## for Internet etc. (DHCP)
# iface eth0 inet dhcp

allow-hotplug wlan0
iface wlan0 inet static
	address 10.10.10.10
	netmask 255.255.255.0
	network 10.10.10.0
\end{lstlisting}

Zur Konfiguration der dynamischen IP-Adressen der Clients im WLAN wird ein DHCP-Server eingerichtet. Ein solcher Server weißt neuen Geräten -- beziehungsweise welchen, die länger nicht im Netzwerk waren -- automatisch eine neue, unverwendete IP-Adresse zu. Hierdurch benötigen die Clients keine spezielle Konfiguration und ihre IP-Einstellungen können auf dem üblichen Standardeinstellungen verbleiben (automatische IP-Adresse beziehen). Als DHCP-Server wird hier das Paket \code{dnsmasq} verwendet. Außer dem DHCP-Server bietet dieses Paket auch einen DNS-Server, der es erlaubt, den Geräten auch einen Hostname zuzuweisen. So wäre der Zugriff zum Beispiel über den Hostname \code{raspberry.ip} anstatt durch Eingabe der IP-Adresse möglich.

Die Konfiguration des DHCP-Servers ist vergleichsweise einfach und benötigt nur das verwendete Netzwerk-Interface, hier wlan0, den zu nutzenden IP-Bereich, die Netzmaske und die Zeit, nach der eine IP-Adresse an ein anderes Gerät vergeben werden darf, die sogenannte Lease-Time (siehe \autoref{dnsmasq}). \citep{accesspoint}

  
\begin{lstlisting}[caption={Konfiguration der \code{/etc/dnsmasq.conf}}, label={dnsmasq}]
interface=wlan0
  dhcp-range=10.10.10.100,10.10.10.254,255.255.255.0,24h
no-dhcp-interface=eth0
\end{lstlisting}

\section{Konfiguration als WLAN-Access-Point}
Um einen Zugriff auf die Python-Weboberfläche des Skriptes und die Konfiguration des Laser\-scan\-ners zu ermöglichen, soll der Rasp\-berry Pi selbst als WLAN-Access-Point fungieren. Hierzu wurde das Paket \code{hostapd} verwendet. Zur Konfiguration werden die Einstellungen in die Datei \code{/etc/hostapd/hostapd.conf} geschrieben. \citep{accesspoint}

\begin{lstlisting}[caption={Konfiguration der \code{/etc/hostapd/hostapd.conf}}, label={hostapd}]
# WLAN-Router-Betrieb

# Schnittstelle und Treiber
interface=wlan0
#driver=nl80211

# WLAN-Konfiguration
ssid=VLPinterface
channel=1
hw_mode=g
ieee80211n=1
ieee80211d=1
country_code=DE
wmm_enabled=1

#WLAN-Verschluesselung
auth_algs=1
wpa=2
wpa_key_mgmt=WPA-PSK
rsn_pairwise=CCMP
wpa_passphrase=hafencity
\end{lstlisting}

Damit die Konfigurationsdatei auch genutzt wird, wird der Pfad in die Konfiguration von \code{hostapd} eingetragen (\code{/etc/default/hostapd}).


\section{Autostart des Skriptes}
Damit das Skript vor der Messung mittels SSH-Zugang gestartet wird, wurde das Skript in den Autostart des Rasp\-berry Pi eingetragen. Hierdurch erfolgt der Start des Skriptes unmittelbar nach dem Hochfahren des Betriebssystems. Durch die Nutzung des Befehls \code{su} wird der Befehl als Nutzer \code{pi}, also ohne Administratorrechte gestartet. Durch Weglassen von \code{su pi -c} kann dieser auch als Administrator gestartet werden. Dies hat jedoch sicherheitstechnische Nachteile, dafür können dann Prioritäten der Befehle gesetzt werden.

\begin{lstlisting}[caption={Startskript startVLP.sh}, label={startskript}]
su pi -c "python3 VdAutoStart.py"
exit 0
\end{lstlisting}

Das Startskript wird mit \code{chmod +x startVLP.sh} ausführbar gemacht und der Pfad zum Skript in der Autostart-Konfigurationsdatei \code{/etc/rc.local} eingetragen.

\section{Einrichtung als Router}
Zusätzlich ist es sinnvoll, den Rasp\-berry Pi auch als Router einzurichten. So lässt sich über die WLAN-Schnittstelle des Rasp\-berry Pi auf die Konfigurationswebseite des Laser\-scan\-ners zugreifen, um Einstellungen des Scanners mobil zu ändern. Hierfür wird die Datei \code{/etc/network/interfaces} um die Zeilen aus \autoref{router} ergänzt. \citep{ekRaspRouter}

%dhcp-option=option:dns-server,192.168.1.1

\begin{lstlisting}[caption={Erweiterung der \code{/etc/network/interfaces} zur Nutzung als Router}, label={router}]
# Firewall-Regel löschen
up /sbin/iptables -F
up /sbin/iptables -X
up /sbin/iptables -t nat -F

# Loopback zulassen
up /sbin/iptables -A INPUT -i lo -j ACCEPT
up /sbin/iptables -A OUTPUT -o lo -j ACCEPT

# NAT und Masquerading aktivieren
up /sbin/iptables -A FORWARD -o eth0 -i wlan0 -m conntrack --ctstate NEW -j ACCEPT
up /sbin/iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
up /sbin/iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE

# IP-Forwarding aktivieren
up sysctl -w net.ipv4.ip_forward=1
up sysctl -w net.ipv6.conf.all.forwarding=1

# hostapd und dnsmasq neu starten
up service hostapd restart
up service dnsmasq restart
\end{lstlisting}


\chapter{Systemüberprüfungen}
\label{c:systemueberpruefung}
Nachdem bei der Systemkonfiguration bisher auf die Angaben aus Handbüchern und Anleitungen vertraut wurde, sollte zusätzlich die Genauigkeit von einigen Systemkomponenten und der Programmierung überprüft werden. Hierfür wurde einmal die Messgenauigkeit des Scanners ausgewählt sowie die Genauigkeit der Zeitangaben der GNSS-Systeme. Die Genauigkeit des GNSS und der in Zusammenhang mit der IMU zu berechnenden Trajektorie hatte bereits \citet{wilken} in seiner Bachelorthesis untersucht.

\section{Untersuchung der Gleichzeitigkeit von PPS-Signalen von verschiedenen GNSS-Empfängern}
Für die Synchronisierung der Daten des Laser\-scan\-ners und der inertialen Messeinheit wurden zwei verschiedene GNSS-Empfänger verwendet. Der für den Einbau in Consumer-Geräte gedachte uBlox-Chip, der am Rasp\-berry Pi und am Laser\-scan\-ner verwendet wird, ist leichter, unabhängiger und einfacher zu realisieren als die Übernahme der Daten mittels Adapterkabeln von der inertialen Messeinheit. Voraussetzung hierfür ist jedoch, dass beide Signale wirklich gleichzeitig erzeugt werden. Um dies zu überprüfen, soll das PPS-Signal (Impulssignal im Sekundentakt) von beiden Messsystemen mit einem Arduino überprüft werden.
Am Arduino werden hierzu an zwei digitalen Eingängen die PPS-Anschlüsse der GNSS-Empfänger angeschlossen. Ein Skript (siehe Anhang~\ref{a:ppsVergleich.ino}) misst dann die Zeit zwischen den beiden Signalen. Diese Messungen werden dann mehrfach hintereinander sowie nach einem Neustart der Systeme durchgeführt. Hiermit soll überprüft werden, ob sich bei einem Neustart der Messung die Zeitdifferenz ändert beziehungsweise dann überhaupt eine Zeitdifferenz entsteht.

Der Test zeigte, dass das Skript keine Zeitdifferenz messen konnte. Daher wurde auf dem Arduino nochmals das Ozilliskop-ähnliche Skript installiert, dass auch schon bei der Untersuchung der NMEA-Übertragung zum Laserscanner genutzt wurde. Hier zeigte sich, dass das PPS-Signal der IMU ein Low-Signal und nicht wie erwartet ein High-Impuls absendet. Dennoch wurde bei einer Abtastrate von 450 Messungen pro Sekunde keine Zeitdifferenz festgestellt (siehe \autoref{img:osPPS}). Außerdem konnte hiermit dann auch festgestellt werden, dass das Signal der IMU nicht den Anforderungen des Velodyne VLP-16 entspricht: Hier wird ein Signal mit einer Impulsdauer von mindestens 10~ms gefordert. Dies wird scheinbar nicht eingehalten, da der Arduino, der mit einer Taktrate von 2,2ms misst, nicht alle Signale der IMU erkennen konnte (siehe erster Puls auf \autoref{img:osPPS}). Außerdem müsste auch hier das Signal elektrisch gedreht werden.

\begin{figure}[!ht]
 \centering
 \includegraphics[width=1\textwidth]{./img/osziPPS.png}
 % Strahlengang.eps: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=0 0 3066 4000
 \caption{Messung der PPS-Signale, in grün die Daten der IMU, in rot die des uBlox-Chips (1000 Punkte entsprechen 5 Volt)}
 \label{img:osPPS}
\end{figure}

\section{Messgenauigkeit des Laser\-scan\-ners im Vergleich}
Um die Strecken und Winkelmessung des Laser\-scan\-ners und die Umwandlung der Daten zu überprüfen, wurden drei verschiedene Messungen an der Hafencity Universität mit dem Velodyne VLP-16 durchgeführt. 


% Hierbei sollte vor allem die Streckenmessung überprüft werden. Das zweite Messszenario fand in der Tiefgarage der HafenCity Universität statt. Sie ist etwa 100 Meter lang und von vielen eckigen Säulen durchzogen. Hier bot es sich an, die Wiederholungsgenauigkeit in Strecke und Richtung des Laser\-scan\-ners zu überprüfen und zusätzlich boten die Säulen verschiedene Entfernungen und Auftreffwinkel. Die meisten Oberflächen bestanden hier aus weiß gestrichenenm Beton.

\paragraph{Datenformate}
Die Daten des Velodyne VLP-16 wurden mit dem in dieser Arbeit entwickelten Skript aufgezeichnet und umgewandelt. Da hierbei auffiel, dass einige Programme besser mit XYZ-Dateien umgehen können, wurde das Klassenmodell um dieses Dateiformat erweitert.

\begin{figure}[!ht]
 \centering
 \includegraphics[width=0.45\textwidth]{./img/fassade.jpg}
 \includegraphics[width=0.45\textwidth]{./img/tiefgarage.jpg}
 % Strahlengang.eps: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=0 0 3066 4000
 \caption{Messungen mit dem Velodyne VLP-16, Zoller+Fröhlich Imager 5010 und dem Trimble S7}
 \label{img:messbilder}
\end{figure}

\subsection{Versuchsmessung in der Tiefgarage}
Hauptsächlich zur Überprüfung der Umformung der Daten, aber auch zur Überprüfung der Streckenmessung und Winkelmessungen wurde eine Messung in der Tiefgarage (\autoref{img:messbilder}, rechts) durchgeführt. Durch die vielen rechtwinkligen Pfeiler sind hier viele Möglichkeiten um Kanten zu detektieren gegeben. Zum Vergleich wurde die Tiefgarage mit einem Trimble S7 mit einer Winkelgenauigkeit von 3 Sekunden und einer prismenlosen Streckengenauigkeit von 2 mm + 2 ppm aufgemessen \citep{trimbles7}.

\paragraph{Auswertung}
Aus den Daten der Tachymetermessung wurden die Wände und Pfeiler der Tiefgarage modelliert. Durch Anpassung der Laserscandaten an diesen Grundriss wurde die Orientierung des Velodyne VLP-16 bestimmt. Die Neigung wurde durch eine Ausgleichung der Fußbodenebene bestimmt. Auch aus den Laserpunktwolken des Velodyne VLP-16 wurden die Kanten der Pfeiler modelliert. Hierfür wurden jeweils Ebenen in die Punkte der Pfeiler- und Wandoberflächen in Geomagic Wrap mittels Ausgleichung eingepasst.

\paragraph{Fehler im Skript} Bei der Auswertung der Messung fiel schon vor dem Vergleich mit der Tachymetermessung auf, dass die Messwerte in Rotationsrichtung verschoben waren. Die Analyse ergab einen Umformungsfehler in der Klasse \code{VdDataset}. Hierdurch wurden die Horizontalrichtungen um bis zu 2 Grad (bei 1200 Umdrehungen pro Minute) fehlerhaft berechnet (siehe \autoref{img:fehlerWolke}). Bei der Messung der Tiefgarage wurden glücklicherweise auch die Rohdaten von zwei der fünf Messreihen gespeichert, so dass hier keine erneute Messung vor Ort nötig war. Die Daten der Fassadenmessung (\autoref{img:messbilder}, links) mussten nochmals wiederholt werden, da die Daten nicht auswertbar waren.

\begin{figure}[!ht]
 \centering
 \includegraphics[width=0.45\textwidth]{./img/punktwolke_f.png}
 \includegraphics[width=0.45\textwidth]{./img/punktwolke_k.png}
 % Strahlengang.eps: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=0 0 3066 4000
 \caption{Punktwolke des Velodyne VLP-16 vor (links) und nach (rechts) der Korrektur der Horizontalrichtung am Beispiel eines Pfeilers in der Tiefgarage}
 \label{img:fehlerWolke}
\end{figure}

\paragraph{Weitere Ergebnisse}
An den Pfeilern, von denen zwei Seiten gut modellierbar waren (siehe \autoref{img:pfeiler}), wurden die Standardabweichungen verglichen, um zu prüfen, ob weitere Fehler in der Berechung der Horizontalrichtungen vorhanden waren. Die Standardabweichungen zu den Ebenen der Tachmetermessung waren auf beiden Seiten ähnlich, so dass von keinen weiteren Fehlern ausgegangen wurde.

\begin{figure}[!ht]
 \centering
 \includegraphics[width=0.60\textwidth]{./img/pfeiler.jpg}
 % Strahlengang.eps: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=0 0 3066 4000
 \caption{Abweichung der Messungen des VLP-16 zu zwei Ebenen der Tachymetermessung in Geomagic Wrap}
 \label{img:pfeiler}
\end{figure}

\subsection{Vergleichsmessung an einer Fassadenfront / im geodätischen Labor}
Eine weitere Messung fand etwa 20 Meter vor einer weißen, rauen und ebenen Fassade (verputztes Wärmedämmverbundsystem) statt. Hier wurden zum Vergleich der Messaufbau komplett von zwei Standpunkten aus mit dem terrestrischem Laser\-scan\-ner Zoller+Fröhlich Imager 5010 gescannt. Durch einen Fehler im Auswerteskript, der erst bei großen Strecken auffiel, waren die Messdaten jedoch leider nicht zu verwenden. Es wurde daher eine ähnliche Messung im geodätischen Labor nachgeholt (siehe \autoref{img:geoLabor}).
Hier wurde der Velodyne VLP-16 mittig im Raum aufgestellt. Zwei Stellwände wurden zur Überprüfung der Entfernungsmessung verwendet. Eine verblieb hierbei immer an der gleichen Stelle, etwa 5 Meter vom Velodyne entfernt stehen, die zweite wurde in verschiedenen Entfernungen aufgestellt (zwischen 6 und 26 Meter). Die Messszenarien wurden jeweils mit dem terrestrischen Laser\-scan\-ner Imager 5010 von Zoller+Fröhlich dokumentiert. Bei Messungen auf weiße Oberflächen liegt die Streckenmessgenauigkeit des Vergleichsscanners unter einem Millimeter \citep{imager5010}. Zum Vergleich mit dem Velodyne VLP-16, der eine angegebene Genauigkeit von 3 Zentimetern hat \citep{vlpSheet}, wird die Messung des Imagers daher als wahrer Wert angenommen.

\begin{figure}[!ht]
 \centering
 \includegraphics[width=0.7\textwidth]{./img/geoLabor.jpg}
 % Strahlengang.eps: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=0 0 3066 4000
 \caption{Messung im geodätischen Labor}
 \label{img:geoLabor}
\end{figure}

\begin{table}[!ht]
\centering
\begin{tabular}{|l|r|r|r|r|}
\cline{2-4}
\hline
		& 		& \multicolumn{2}{r|}{} 	&  Durchschn.\\
		& Entfernung	& \multicolumn{2}{r|}{Standardabweichung} & Abweichung\\
		& in m		& Ausgleichung	& zum Imager 	& zum Imager \\ \hline
Boden		&		& 1,03		&		& 	\\ \hline
Decke		& 	    	& 2,37		&		& 	\\ \hline
feste Tafel	& -5,2		& 1,33		& 2,02		& 1,06	\\ \hline
Tafel 1		& 6,4      	& 1,16		& 1,74		& -0,3	\\ \hline
Tafel 2		& 11,4     	& 0,72		& 0,92		& -0,34	\\ \hline
Tafel 3		& 25,3     	& 1,01		& 1,53		& -0,11	\\ \hline
\end{tabular}
\caption{Abweichungen der Ebenenen bei der Messung im geodätischen Labor}
\label{tab:labor}
\end{table}

\paragraph{Nachbearbeitung der Messdaten}
Die Punktwolken des Imager 5010 wurden in der Software Z+F LaserControl über angebrachte Targets zusammengeführt. Anschließend wurden die Punktwolken gefiltert und in die Software Geomagic Wrap importiert. Hier wurde der Standpunkt des Velodyne VLP-16 bestimmt, in dem ein Zylinder der Größe des VLP-16 automatisch in die ihm zuzuordnenden Punkte der Punktwolke eingepasst wurde.  Hieraus konnte dann der Nullpunkt der Messungen des Velodyne VLP-16 bestimmt werden.
In den Laserpunktwolken der beiden Scanner wurden in Geomagic Wrap die Wände, die Decke und der Fußboden und die Stellwände modelliert. Hierfür wurden die entsprechenden Punkte ausgewählt und mittels Best-Fit-Anpassung Ebenen durch diese ausgeglichen. Über die Wände, die Decke und den Boden wurden die Punktwolken nochmals genauer zu einander ausgerichtet.

\paragraph{Präzision der Streckenmessung}
Beim Modellieren der Wände bestand die Möglichkeit, sich die Genauigkeit der Ausgleichung in den Punkten anzuzeigen. Die von Velodyne angegebene Standardabweichung liegt bei 3 cm \citep{vlpSheet}. Die maximale bestimmte Standardabweichung in der Ausgleichung der Ebenen lag bei etwa 2,4 cm (Ausgleichung der Decke). Die Standardabweichung der Stellwände (siehe Spalte 3, \autoref{tab:labor}) lag bei maximal 1,3 cm. Die Angaben wurden bei der Wiederholungsmessung also eingehalten.

\paragraph{Richtigkeit der Streckenmessung}
Um zu überprüfen, ob nicht nur die Wiederholungsgenauigkeit des Velodyne VLP-16 im angegeben Bereich liegt, wurden die Positionen der modellierten Stellwände aus den Datensätzen des Velodyne mit denen des Imager 5010 verglichen. Hierzu wurden mit Geomagic Wrap die Abweichung der Punkte des Velodyne zu den Ebenen bestimmt. Hier lag die Standardabweichung nur minimal über den Werten der Ausgleichung der Messwerte selbst (siehe Spalte 4, \autoref{tab:labor}). Die durchschnittliche Abweichung (Spalte 5) zeigt, das die etwas höhere Standardabweichung auch an der Einpassung der Daten liegen kann, denn die durchschnittliche Abweichung zeigt eine Korrelation mit der Entfernung. Auch hier zeigt sich, dass der Velodyne seine angegebene Genauigkeit einhält.

\chapter{Ausblick}
\label{c:ausblick}

\paragraph{Weiterverarbeitung der Daten}
Die Umformung und Speicherung der Daten war nur ein erster Schritt zur Entwicklung des Air\-borne Laser\-scan\-ning Systems. Es ist so zwar möglich, die Daten vom Laser\-scan\-ner, der inertialen Messeinheit und des GNSS zu speichern, jedoch müssen diese Daten weiter prozessiert werden. Bisher wurde der Scanner nur stationär zur Messung eingesetzt. Um  ihn auch kinematisch nutzen zu können, müssen aus den Daten der IMU die Bewegungen rekonstruiert werden. Hiermit können dann die Messungen in ein übergeordnetes Bezugssystem überführt werden. Diese Verarbeitung wird in einer Folgearbeit behandelt werden.

\paragraph{Weitere Genauigkeitsüberprüfungen}
Die bisherigen Genauigkeitsüberprüfungen wurden hauptsächlich zur Überprüfung auf Fehler in der Berechung und Auswertung durchgeführt. Vorallem die Messgenauigkeit des Laserscanners ist noch deutlich detailierter zu untersuchen. Aber auch die Zeitdifferenzen zwischen den Systemen sollten vor einem produktiven Einsatz noch weiter analyisiert werden.

\paragraph{Anwendbarkeit des Messsystems}
Da das fertige Messsystem keine Abhängigkeiten vom Multikopter hat, kann es nicht nur fliegend, sondern auch terrestrisch verwendet werden. Einzige Bedingung der Nutzung ist die freie Sicht zum Himmel für den GNSS-Empfang. Auch eine Montage des Systems, gegebenenfalls auch unter Nutzung der Gimbal, an andere, bodengebundene Fahrzeuge wäre denkbar. Hiermit ließen sich beispielsweise Straßenzügen für 3D-Stadtmodelle digitalisieren. Zuerst würden die Straßen und Wege mit Autos, Fahrrädern oder einem Bollerwagen bodengebunden aufgenommen werden und anschließend mit dem gleichen Messsystem an einem Multikopter montiert von oben. So wäre mit einem Messesystem die nahtlose Erfassung der gesamten Gebäudehülle möglich.

\paragraph{Erweiterungs- und Optimierungsmöglichkeiten}
In der Programmierung des Rasp\-berry Pi sind noch Verbesserungen und Optimierungen möglich. Eine sinnvolle Erweiterung ist zum Beispiel in der Konfiguration des Rasp\-berry Pi als Router für den Zugriff auf den Laser\-scan\-ner. Hiermit ist es dann möglich, Einstellungen mobil durchzuführen. Programmiertechnisch könnten die restlichen Skripte noch in ihrer Geschwindigkeit der Ausführung optimiert werden.

\paragraph{Gehäuse}
Auch das Gehäuse befindet sich noch in der Entwicklung. Bisher exisiert nur ein mit einem 3D-Drucker erstellter Entwurf (siehe \autoref{abb:system}. Jedoch ist dieser noch zu instabil, um im Flug die Technik zu halten. Eine Möglichkeit wäre es, ein solches, gelochtes Gehäuse aus Aluminium zu bauen. Außerdem sollten vor einem Einsatz auch noch die Kabel entsprechend der benötigten Länge konfektioniert werden, um die Gefahr des Hängenbleibens zu vermindern.

\begin{figure}[!ht]
 \centering
 \includegraphics[width=1\textwidth]{img/system.jpg}
 \caption{Prototyp des Messsystems (noch ohne Akkumulatoren)}
 \label{abb:system}
\end{figure}

\todo{Erweitern}



%% Literatur
\renewcommand\UrlFont\itshape
\bibliography{Thesis}
%\printbibliography
no-dhcp-interface=eth0
\listoffigures
\listoftables
%\lstlistoflistings

\renewcommand{\appendixpagename}{\appendixname} 
\renewcommand{\appendixtocname}{\appendixname} 
\begin{appendices}

\chapter{Python-Skripte}
\label{a:skripte}
\section{vdAutoStart.py}
\label{a:vdAutoStart.py}
\lstinputlisting[language=Python]{../Quelltext/Python/vdAutoStart.py}

\section{vdBuffer.py}
\label{a:vdBuffer.py}
\lstinputlisting[language=Python]{../Quelltext/Python/vdBuffer.py}

\section{vdTransformer.py}
\label{a:vdTransformer.py}
\lstinputlisting[language=Python]{../Quelltext/Python/vdTransformer.py}

\section{vdInterface.py}
\label{a:vdInterface.py}
\lstinputlisting[language=Python]{../Quelltext/Python/vdInterface.py}

\section{vdGNSSTime.py}
\label{a:vdGNSSTime.py}
\lstinputlisting[language=Python]{../Quelltext/Python/vdGNSSTime.py}

\section{vdHardware.py}
\label{a:vdHardware.py}
\lstinputlisting[language=Python]{../Quelltext/Python/vdHardware.py}

\section{vdFile.py}
\label{a:vdFile.py}
\lstinputlisting[language=Python]{../Quelltext/Python/vdFile.py}

\section{vdASCIIFile.py}
\label{a:vdASCIIFile.py}
\lstinputlisting[language=Python]{../Quelltext/Python/vdASCIIFile.py}

\section{vdTxtFile.py}
\label{a:vdTxtFile.py}
\lstinputlisting[language=Python]{../Quelltext/Python/vdTxtFile.py}

\section{vdObjFile.py}
\label{a:vdObjFile.py}
\lstinputlisting[language=Python]{../Quelltext/Python/vdObjFile.py}

\section{vdXYZFile.py}
\label{a:vdXYZFile.py}
\lstinputlisting[language=Python]{../Quelltext/Python/vdXYZFile.py}

\section{vdSQLite.py}
\label{a:vdSQLite.py}
\lstinputlisting[language=Python]{../Quelltext/Python/vdSQLite.py}

\section{vdDataset.py}
\label{a:vdDataset.py}
\lstinputlisting[language=Python]{../Quelltext/Python/vdDataset.py}

\section{vdPoint.py}
\label{a:vdPoint.py}
\lstinputlisting[language=Python]{../Quelltext/Python/vdPoint.py}

\section{config.ini}
\label{a:config.ini}
\lstinputlisting[]{../Quelltext/Python/config.ini}

\section{convBin.py}
\label{a:convBin.py}
\lstinputlisting[language=Python]{../Quelltext/Python/convBin.py}

\section{convBinC++.py}
\label{a:convBinCpp.py}
\lstinputlisting[language=Python]{../Quelltext/Python/convBinC++.py}

\section{convTxt.py}
\label{a:convTxt.py}
\lstinputlisting[language=Python]{../Quelltext/Python/convTxt.py}

\chapter{C++-Quelltexte}
\label{a:cpp}

\section{main.cpp}
\label{a:main.cpp}
\lstinputlisting[language=C++]{../Quelltext/C++/src/main.cpp}

\section{VdFile.h}
\label{a:VdFile.h}
\lstinputlisting[language=C++]{../Quelltext/C++/src/VdFile.h}

\section{VdFile.cpp}
\label{a:VdFile.cpp}
\lstinputlisting[language=C++]{../Quelltext/C++/src/VdFile.cpp}

\section{VdASCIIFile.h}
\label{a:VdASCIIFile.h}
\lstinputlisting[language=C++]{../Quelltext/C++/src/VdASCIIFile.h}

\section{VdASCIIFile.cpp}
\label{a:VdASCIIFile.cpp}
\lstinputlisting[language=C++]{../Quelltext/C++/src/VdASCIIFile.cpp}

\section{VdObjFile.h}
\label{a:VdObjFile.h}
\lstinputlisting[language=C++]{../Quelltext/C++/src/VdObjFile.h}

\section{VdObjFile.cpp}
\label{a:VdObjFile.cpp}
\lstinputlisting[language=C++]{../Quelltext/C++/src/VdObjFile.cpp}

\section{VdTxtFile.h}
\label{a:VdTxtFile.h}
\lstinputlisting[language=C++]{../Quelltext/C++/src/VdTxtFile.h}

\section{VdTxtFile.cpp}
\label{a:VdTxtFile.cpp}
\lstinputlisting[language=C++]{../Quelltext/C++/src/VdTxtFile.cpp}

\section{VdXYZFile.h}
\label{a:VdXYZFile.h}
\lstinputlisting[language=C++]{../Quelltext/C++/src/VdXYZFile.h}

\section{VdXYZFile.cpp}
\label{a:VdXYZFile.cpp}
\lstinputlisting[language=C++]{../Quelltext/C++/src/VdXYZFile.cpp}

\section{VdSQLite.h}
\label{a:VdSQLite.h}
\lstinputlisting[language=C++]{../Quelltext/C++/src/VdSQLite.h}

\section{VdSQLite.cpp}
\label{a:VdSQLite.cpp}
\lstinputlisting[language=C++]{../Quelltext/C++/src/VdSQLite.cpp}

\section{VdDataset.h}
\label{a:VdDataset.h}
\lstinputlisting[language=C++]{../Quelltext/C++/src/VdDataset.h}

\section{VdDataset.cpp}
\label{a:VdDataset.cpp}
\lstinputlisting[language=C++]{../Quelltext/C++/src/VdDataset.cpp}

\section{VdPoint.h}
\label{a:VdPoint.h}
\lstinputlisting[language=C++]{../Quelltext/C++/src/VdPoint.h}

\section{VdPoint.cpp}
\label{a:VdPoint.cpp}
\lstinputlisting[language=C++]{../Quelltext/C++/src/VdPoint.cpp}

\section{VdXYZ.h}
\label{a:VdXYZ.h}
\lstinputlisting[language=C++]{../Quelltext/C++/src/VdXYZ.h}

\section{VdXYZ.cpp}
\label{a:VdXYZ.cpp}
\lstinputlisting[language=C++]{../Quelltext/C++/src/VdXYZ.cpp}

\chapter{Arduino-Quelltext}
\section{ppsVergleich.ino}
\label{a:ppsVergleich.ino}
\lstinputlisting[language=C++]{../Quelltext/arduino/ppsVergleich/ppsVergleich.ino}

\chapter{Beispieldateien}

\section{Rohdaten vom Scanner}
\label{a:Rohdaten}

{\color{gray} Netzwerk-Header}\\
{\color{red} Flag (FF EE)} {\color{green} Horizontalrichtung}\\
{\color{blue} Strecke} {\color{orange} Reflektivität}\\
{\color{yellow} Timestamp } {\color{violet} Return-Modus}\\
\\

\newcommand\tab[1][1cm]{\hspace*{#1}}
\noindent\code{0000\tab{\color{gray} ff ff ff ff ff ff 60 76 88 00 00 00 08 00 45 00}\\
0010\tab{\color{gray} 04 d2 00 00 40 00 ff 11 b4 aa c0 a8 01 c8 ff ff}\\
0020\tab
{\color{gray} ff ff 09 40 09 40 04 be 00 00}
{\color{red} ff ee} {\color{green} 02 4d}
{\color{blue} 00 00}\\
0030\tab
{\color{orange} 0f}
{\color{blue} 00 00} {\color{orange} 0a}
{\color{blue} 00 00} {\color{orange} 16}
{\color{blue} f0 01} {\color{orange} 04}
{\color{blue} 00 00} {\color{orange} 0d}
{\color{blue} 00 00} {\color{orange} 0a}\\
0040\tab
{\color{blue} 00 00} {\color{orange} 0d}
{\color{blue} 00 00} {\color{orange} 06}
{\color{blue} 00 00} {\color{orange} 0b}
{\color{blue} 00 00} {\color{orange} 08}
{\color{blue} 00 00} {\color{orange} 10}
{\color{blue} 00}\\
0050\tab
{\color{blue} 00} {\color{orange} 05}
{\color{blue} 92 01} {\color{orange} 05}
{\color{blue} 00 00} {\color{orange} 04}
{\color{blue} 00 00} {\color{orange} 0f}
{\color{blue} 00 00} {\color{orange} 07}
{\color{blue} 00 00}\\
0060\tab
{\color{orange} 0f}
{\color{blue} 00 00} {\color{orange} 0a}
{\color{blue} 00 00} {\color{orange} 16}
{\color{blue} e6 01} {\color{orange} 08}
{\color{blue} 00 00} {\color{orange} 0d}
{\color{blue} 00 00} {\color{orange} 0a}\\
0070\tab
{\color{blue} 00 00} {\color{orange} 0d}
{\color{blue} 00 00} {\color{orange} 06}
{\color{blue} 00 00} {\color{orange} 0b}
{\color{blue} 00 00} {\color{orange} 08}
{\color{blue} 00 00} {\color{orange} 10}
{\color{blue} 00}\\
0080\tab
{\color{orange} 00 05}
{\color{blue} 7e 01} {\color{orange} 05}
{\color{blue} 00 00} {\color{orange} 04}
{\color{blue} 00 00} {\color{orange} 0f}
{\color{blue} 00 00} {\color{orange} 07}
{\color{red} ff ee}\\
0090\tab
{\color{green} 02 4d}
{\color{blue} 00 00} {\color{orange} 0f}
{\color{blue} 00 00} {\color{orange} 0a}
{\color{blue} 00 00} {\color{orange} 16}
{\color{blue} f0 01} {\color{orange} 04}
{\color{blue} 00 00}\\
...\\
04d0\tab
{\color{orange} 05}
{\color{blue} 00 00} {\color{orange} 04} 
{\color{blue} 00 00} {\color{orange} 0f}
{\color{blue} 00 00} {\color{orange} 07}
{\color{yellow} 8c 25 44 63} {\color{violet} 39 22}
}


\section{Dateiformat für Datenspeicherung als Text}
\label{a:AusgabeTXT}
\lstinputlisting[firstline=1, lastline=20]{../Aufzeichnungen/test.txt}

\section{Dateiformat für Datenspeicherung als OBJ}
\label{a:AusgabeOBJ}
\lstinputlisting[firstline=1, lastline=20]{../Aufzeichnungen/test.txt.obj}


\end{appendices}

\newpage
\noindent\textbf{\large Erklärung}\\
Hiermit versichere ich, dass ich die beiliegende Bachelor-Thesis ohne fremde Hilfe selbst\-stän\-dig verfasst und nur die angegebenen Quellen und Hilfsmittel benutzt habe.\\
\\
Wörtlich oder dem Sinn nach aus anderen Werken entnommene Stellen sind unter Angabe der Quellen kenntlich gemacht. 
\\
\\
\\
\\
\noindent{\underline{Hamburg, den 12. Dez. 2017~\hspace{10cm}}}\\
\noindent{\small Ort, Datum \hspace{4.5cm} Florian Timm}


\end{document}