\documentclass[a4paper,12pt,bibliography=totoc, listof=totoc,titlepage,pointlessnumbers]{scrreprt}
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage[left=3cm,right=2.5cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage[onehalfspacing]{setspace}
\renewcommand{\arraystretch}{1.5}
\usepackage{graphicx}
\usepackage[toc,page]{appendix}
%\usepackage{pdfpages}  
\usepackage[hyphens]{url}
\usepackage[hidelinks]{hyperref}
\usepackage{todonotes}
\usepackage{amsmath}
\usepackage{multirow}
\newcommand{\code}[1]{\texttt{#1}}
%\usepackage{tocloft}

%Boxfehler
\hbadness=10

% Listings
\usepackage{listings}
\lstset{
   captionpos=t,
   basicstyle=\scriptsize\ttfamily,
   keywordstyle=\bfseries\ttfamily\color{orange},
   stringstyle=\color{green}\ttfamily,
   commentstyle=\color{gray}\ttfamily,
   emph={square}, 
   emphstyle=\color{blue}\texttt,
   emph={[2]root,base},
   emphstyle={[2]\color{yac}\texttt},
   showstringspaces=false,
   flexiblecolumns=false,
   tabsize=2,
   numbers=left,
   numberstyle=\tiny,
   numberblanklines=false,
   stepnumber=1,
   numbersep=10pt,
   xleftmargin=15pt
 }

% Zitierstil
\usepackage[round]{natbib}
\bibliographystyle{hcu}

\begin{document}
\pagenumbering{Roman}
\begin{titlepage}
\begin{center}
\renewcommand{\arraystretch}{0.7}
\begin{tabular}{lr}
\begin{tabular}{l}
\includegraphics[width=0.4\textwidth]{img/hcu-hamburg.pdf}
\end{tabular} \hspace{1cm} &
\begin{tabular}{r}
Universität für \\Baukunst und Metropolenentwicklung\\
Studiengang Geomatik\\
Überseeallee 16\\
20457 Hamburg\\
\end{tabular}
\end{tabular}\\\vspace{5cm}
\doublespacing 
{\huge\bfseries Entwurf und Implementierung einer Daten-Schnittstelle zum Betrieb eines Laserscanner VLP-16 an einem
Raspberry Pi}\vspace{0.5cm}\\
\onehalfspacing
{\large\bfseries Bachelorthesis}\vspace{2cm}\\
{\large vorgelegt von:}\\
{\large Florian Timm}\\

\vspace{7cm}
Mittwoch, den 13. Dezember 2017\\
\end{center}
\setcounter{page}{0} 
\end{titlepage}
\vspace{2cm}
\noindent\textbf{\large Verfasser}\\
Florian Timm\\
Matrikelnummer: 6028121\\
Gaiserstraße 2, 21073 Hamburg\\
\\
E-Mail: florian.timm@hcu-hamburg.de\\
\vspace{3cm}\\
\noindent\textbf{\large Erstprüfer}\\
Prof. Dr. rer. nat. Thomas Schramm\\
HafenCity Universität Hamburg\\
Überseeallee 16, 20457 Hamburg\\
\\
E-Mail: thomas.schramm@hcu-hamburg.de\\
\vspace{3cm}\\
\textbf{\large Zweitprüfer}\\
Dipl.-Ing. Carlos Acevedo Pardo\\
HafenCity Universität Hamburg\\
Überseeallee 16, 20457 Hamburg\\
\\
E-Mail: carlos.acevedo@hcu-hamburg.de\\
\newpage
\noindent\textbf{\large Kurzzusammenfassung}\\
Die vorliegende Arbeit ist Teil eines Projektes, dass die Entwicklung eines Systems zum Ziel hat, welches den modular austauschbaren Betrieb verschiedenster Sensorsysteme an einem Multikopter erlauben soll. Im Speziellen soll hier die Datenschnittstelle von einem Kompakt-Laserscanner Velodyne Lidar Puck VLP-16 zu einem Einplatinencomputer Raspberry Pi entwickelt und implementiert werden. Der Scanner selbst liefert hierbei die Daten in einem proprietären, binären Format, welche in ein einfach lesbares Format, hier eine ASCII-Datei, umgewandelt und gespeichert werden sollen. Außerdem sollen die Daten mit einem eindeutigen Zeitstempel versehen werden, um diese später mit anderen Sensorsystemen verknüpfen zu können. Diese Datentransformation sollte möglichst simultan zur Aufnahme erfolgen.

Auch Teil der Arbeit ist die Schaffung einer Steuerung der Aufnahme des Laserscanners. Hierfür wurde ein Bedienmodul entwickelt, welches am Raspberry Pi direkt angeschlossen werden kann, sowie eine Steuerungsweboberfläche eingebunden, die die Steuerung während des Fluges ermöglichen soll.\\
\vspace{2cm}\\
\noindent\textbf{\large Abstract}\\
The present work is part of a project aimed the development of a system that allows the modular interchangeable operation of various sensor systems on a multicopter. In particular, the data interface for compact laser scanner Velodyne Lidar Puck VLP-16 to a single-board computer Raspberry Pi will be developed and implemented. The scanner itself provides the data in a proprietary, binary format, which should be converted and stored into an easy-to-read ASCII file. In addition, the data should be provided with a unique timestamp in order to be able to link it later with other sensor systems. This data transformation should be carried out as simultaneously as possible while recording.

Also part of the work is the creation of a control of the recording of the laser scanner. For this purpose, an operating module was developed, which can be connected directly to the Raspberry Pi, as well as a web control surface integrated in the software, which should enable the control during the flight.


% Mehrere gleichzeitig zitieren
\providecommand{\citeTwo}[4]{\citep[{\citealp[#1]{#2};}][#3]{#4}} 
\providecommand{\citeThree}[6]{\citep[{\citealp[#1]{#2}; \citealp[#3]{#4};}][#5]{#6}} 
\providecommand{\citeFour}[8]{\citep[{\citealp[#1]{#2}; \citealp[#3]{#4}; \citealp[#5]{#6};}][#7]{#8}}.

\newpage

\tableofcontents
\newpage

\pagenumbering{arabic}
\setcounter{page}{1} 

\chapter{Einleitung}

\section{Problemstellung}
Daten aus Airborne Laserscanning, dem Abtasten von Oberflächen mit einem Laserscanner aus der Luft, lassen sich für viele verschiedene Zwecke benutzen. Oft werden sie zur Erfassung von digitalen Geländemodellen verwendeten, aber auch für die Erstellung von Stadtmodellen oder Vegetationsanalysen sind die Daten nutzbar. Aktuell werden als Trägersysteme des Laserscanner Helikopter oder Flugzeuge verwendet, die mit entsprechender Sensorik ausgerüstet sind. Diese Messmethode lohnt sich allerdings nicht für kleiner Gebiete und ist auch aufgrund der Größe und die Gefahren des Fluggerätes nicht für die Aufnahme feiner Strukturen wie Fassaden geeignet, bei denen zwischen Häuserschluchten geflogen werden müsste. Außerdem sind die Betriebs- und Anschaffungskosten sind sehr hoch, so dass sich eine solche Messung oft nur für sehr große Gebiete lohnt. Alternativ bietet sich die terrestrische Messungen mittels Tachymeter oder auch per Laserscanner an um kleinere Gebiete abzubilden -- hier benötigt die Aufnahme jedoch viel Zeit und Personal. Hinzukommt, dass die Genauigkeit für viele Anwendungsfälle der 3D-Modelle zu hoch ist. Beide Möglichkeiten, die Messung aus der Luft oder vom Boden, sind sehr kostenintensiv. Ein Lösungsansatz hierfür wäre es, anstatt eines Helikopters als Trägersystem, einen Multikopter zu nutzen. Jedoch ist die Tragfähigkeit für die meisten Laserscanning-Systeme nicht ausreichend. Daher basieren 3D-Erfassungssysteme mittels Multikoptern heutzutage meist auf photogrammetrischen Prinzipien, welche Luftbilder zur nutzen. Hierzu muss jedoch ausreichend Beleuchtung vorhanden sein, welches wiederum die Einsetzbarkeit des Systemes in Städten beschränkt, in denen nur nachts für ausreichende Sicherheitszonen zum Betrieb von Multikoptern gesorgt werden kann. 

\section{Zielsetzung}
Gesamtziel ist es ein Laserscanning-System zu entwickeln, dass von einem Multikopter getragen werden kann. Hierbei soll vorallem auf ein geringes Gewicht geachtet, aber auch die Kosten niedrig gehalten werden. Im Speziellen soll hier als erster Schritt die Datenverarbeitung des Laserscanners in einem solchen System realisiert werden. Hierfür soll ein Ein-Platinen-Computer Typ Raspberry Pi 3 die Speicherung und Aufbereitung der von einem Laserscanner Velodyne Puck VLP-16 aufgezeichneten Laserpunktdaten übernehmen. Hierfür müssen entsprechende Schnittstellen zum Verbinden der Geräte in Hard- und Software entwickelt werden.

\section{Struktur}
Im \autoref{c:grundlagen} sollen die Grundlagen des luftgestützten Laserscanning erläutert werden. Außerdem wird die benötigte Hardware zur Durchführung eines solchen Laserscanning besprochen. Im folgenden wird näher auf die Realisierung des Projektes eingegangen: Welche Hardware wurde verwendet und wie wurde Sie angeschlossen (\autoref{c:realisierung}), wie sollen die Daten verarbeitet werden (\autoref{c:datenverarbeitung}) und wie wird die Verarbeitung schließlich durchgeführt (\autoref{c:skript}) und das System konfiguriert (\autoref{c:konfig}). Zum Abschluss soll in \autoref{c:ausblick} noch ein Einblick in die Zukunft des Systemes geworfen werden.

\chapter{Grundlagen des Airborne Laserscanning}
\label{c:grundlagen}

Airborne Laserscanning bezeichnet das Verfahren, bei dem ein Laserscanner, welcher an einem Fluggerät befestigt ist, Oberflächen kontaktlos dreidimensional erfasst \citep[S. 1]{beraldin}. Der Laserscanner liefert hierbei Daten in Form von der Abstrahlrichtung des Strahles und der Entfernung, relativ zu seiner eigenen Ausrichtung und Position. Um diese lokalen Daten in ein globales System zu überführen, werden zusätzlich die Ausrichtung und die Position des Laserscanners zum Zeitpunkt der Messung benötigt \citep[S. 22f]{beraldin}. Diese Daten liefern im Normalfall eine Inertiale Messeinheit (siehe \autoref{s:IMU}) und ein Satellitennavigationsempfänger (siehe \autoref{s:GNSS}).

\section{Laserscanner}
Ein Laserscanner besteht grundlegend aus einer Laser-Entfernungsmesseinheit und einer Ablenkeinheit. Für beide Teile gibt es verschiedenste Bauformen, auf die im folgenden eingegangen wird.

\subsection{Entfernungsmessung}
Für Messung der Entfernung werden zwei verschiedene Prinzipien angewandt.

Bei der Laufzeitmessung wird ein Laserimpuls ausgesandt. Mit dem Aussenden startet ein hochgenauer Timer seine Messung. Beim Eintreffen des an einer Oberfläche reflektierten Strahles beim Laserscanner wird der Timer gestoppt. Aus dieser gemessenen Laufzeit lässt sich die zurückgelegte Strecke des Lichtstrahles und somit die doppelte Entfernung der Oberfläche bestimmen. Hierzu wird der Brechungsindex \(n\) des vom Laser durchlaufenen Mediums benötigt. Aus der bekannten Lichtgeschwindigkeit \(c_0\) und der benötigten Zeit \(t\) lässt sich dann die Entfernung \(s\) mit der \autoref{equ:entfernung} berechnen.

\begin{equation}
\begin{aligned}
s &=  \frac{c_0}{n} \cdot \frac{t}{2}  && \left|\  \text{Streckenberechnung} \right. \\
\end{aligned}
\label{equ:entfernung}
\end{equation}

\paragraph{Phasenvergleichsverfahren}
Eine andere, weitaus häufiger verwendete Methode, ist das Phasenvergleichsverfahren. Hierbei wird nicht direkt die Zeit gemessen sondern ein kontinuierlichen Lichtstrahl mit einer Sinusschwingung amplitudenmoduliert (Intensivitäts- bzw. Helligkeitsschwankungen). Hierdurch können weniger frequente Wellen (Modulationswelle) verwendet werden, wodurch sich bei guten Ausbreitungseigenschaften der hochfrequenten Trägerwellen die leichtere Verarbeitbarkeit von längeren Wellen ausnutzen lässt. Durch Messung des Phasenunterschiedes des Messstrahles, kann auf die Reststrecke der nicht-vollständigen Phasen des Messstrahles geschlossen werden. Als Trägerwelle wird zur normalen Messung auf einen Reflektor Infrarotlicht mit einer Wellenlänge von etwa 900nm verwendet. Dieses kann mit einer Galliumarsenid-Leuchtdiode einfach erzeugt und direkt durch Spannungsschwankungen moduliert werden. Außerdem hat diese Wellenlänge gute Ausbreitungseigenschaften. Die hierfür benötigte Modulationswelle wird durch ein Quarzoszillator erzeugt. Ein hier verbautes Quarzplättchen wird durch Anlegen einer Spannung in eine Schwingung versetzt, welche im Gegensatz zu anderen Oszillatorenschaltungen seine Frequenz sehr genau einhalten kann. Die Schwingung wird dann verstärkt und an den Infrarot-Laser geleitet, so dass dieser das modulierte Infrarotlicht aussendet. Die maximal eindeutig messbare Entfernung ist direkt von der längsten verwendeten Wellenlänge, dem Grobmaßstab, abhängig: Da nur die Phasenunterschiede und nicht die Anzahl der Schwingungen gemessen werden kann, ist die maximale eindeutige  Streckenmessung genau halb so groß wie die maximale Wellenlänge, da mit dem Reflektor die Strecke doppelt (Hin- und Rückweg) gemessen wird. Wenn längere Strecken als die halbe Wellenlänge gemessen werden, ist dem Gerät nicht bekannt, wie viele ganze Wellen das Licht schon zurückgelegt hat. Das Signal ist bei zu langen Strecken mehrdeutig. Zur Messung der Phase werden die ausgesendete und die eingehende Messwelle mit einer Überlagerungsfrequenz vermischt, die aus diesen beiden hochfrequenten Wellen eine niederfrequente Welle macht. Die Überlagerungsfrequenz hat die Frequenz der Summe der Modulationsfrequenz und der gewünschten Niederfrequenz. Hierdurch wird die Verarbeitbarkeit der Wellen vereinfacht. Da die Genauigkeit der Zeit-Messung begrenzt ist, wird durch Nutzung verschiedener Wellenlängen eine Genauigkeitssteigerung durchgeführt werden. Nach der groben Messung mit einer langen Wellenlänge, wird die Genauigkeit durch die Verwendung immer kürzerer Modulationswellen gesteigert. Eine grobe Messung ist jedoch vorher notwendig, da ansonsten die Anzahl der ganzen Schwingungen des Messstrahles unbekannt ist. \citep[S. 311ff]{Witte2006}

\paragraph{Zeitmessung}
Bei beiden Verfahren ist ein Problem die genaue Zeitmessung. Eine Möglichkeit dieser Messung ist die Nutzung eines Frequenzgenerators, welcher Zählimpulse erzeugt. Diese werden dann zwischen zwei Flanken der zu messenden Ausgangs- und Eingangswellen mehrfach gezählt und gemittelt und ergeben so zum Beispiel die Phasenverschiebung. Dieses Verfahren wird als digitale Messung bezeichnet. Eine andere Methode ist die analoge Messung. Hierbei öffnet die eine Flanke den Stromfluss zu einem Kondensator, die Flanke der anderen Welle schließt sie wieder. Aus der Ladung des Kondensators kann dann auf den Phasenwinkel und die Phasenverschiebung geschlossen werden.  \citep[S. 314f]{Witte2006}

\subsection{Ablenkeinheit}
Bei den meisten Laserscannern ist nur eine Laserentfernungsmesseinheit verbaut. Um hiermit verschiedene Punkte messen zu können, muss der Laserstrahl durch geeignete Verfahren abgelenkt werden. Auch hierfür gibt es im Airborne Laserscanning verschiedenste Ansätze:
\citeTwo{S. 23ff}{ALS}{S. 16ff}{beraldin}

\paragraph{Schwenkspiegel}
Der Laserstrahl wird auf einen schwingenden, flachen Spiegel gerichtet. Durch die Schwingung wird der Laserstrahl in einer Ebene nach Links und Rechts abgelenkt. Durch die Bewegung des Fluggerätes wird der Laser so in Richtung der Schwingachse ensteht so auf der Oberfläche eine Zick-Zack-Linie als Messmuster.

\paragraph{Rotierender Polygon-Spiegel}
Beim drehenden Polygon-Spiegel dreht sich ein Prisma mit einem gleichseitigen Polygon in der Achse der Flugbewegung. Seine rechteckigen Seiten sind verspiegelt und der Laser auf diese gerichtet. Von oben gesehen wird der Strahl somit immer nur in eine Richtung abgelenkt und springt dann wieder zurück auf die andere Seite. Es entsteht ein Streifenmuster.

\paragraph{Palmer Scanner}
Beim Palmerscanner rotiert ein Flachspiegel um eine Achse, die fast senkrecht zur Spiegeloberfläche steht. Da der Spiegel nicht genau senkrecht auf dieser Achse montiert ist, beschreibt der auf den Spiegel gerichtete Laser einen Kreis. Durch einen im 45 Grad Winkel zur Achse stehenden Spiegel und einem sich in der Drehachse befindenen Scanner können die Strahlen auch rechtwinklig abgelenkt werden und somit eine Ebene scannen. Dies wird häufig bei terrestrischen Laserscannern im Zusammenhang mit einer zweiten Drehachse angewandt.

\paragraph{Glasfaser-Scanner}
Der Glasfaserscanner nutzt zur Ablenkung zusätzlich Glasfasern, welche fest verklebt sind. Hierdurch sind die Winkel zur Seite festgegeben. Zum Beispiel ein Polygonspiegel wie er zuvor beschrieben wurde, reflektiert den Messstrahl in die jeweiligen Faserbündel. Die Ablenkungswinkel sind fest vom Hersteller vorgeben.

\paragraph{Zusätzliche Achsen}
Zusätzlich zu den Spiegelmechanismen verfügen viele, vorallem die terrestrische Laserscanner über eine weitere Drehachse. Das Scanmodul dreht sich hier um sich selbst und ermöglicht so das Scannen des kompletten Panoramas.

\todo{Bild malen}

\section{Positionsbestimmung mittels globalen Navigationssatellitensystemen}
\label{s:GNSS}
Zur Bestimmung der Position des Fluggerätes wird ein Empfänger für globale Satellitennavigationssysteme (global navigation satellite system, GNSS) verwendet. Ein solcher Empfänger kann durch die Laufzeitbestimmung des Signales von verschiedenen Satelliten zum Beispiel des US-amerikanischen Navstar GPS seine aktuelle Position bestimmen. Hierzu ist eine freie Sicht zum Himmel notwendig. Je nach Auswertung und Weiterverarbeitung des Signales sind Genauigkeiten zwischen 10 Metern ohne zusätzliche Daten und wenigen Millimetern bei statischen Dauermessungen und dem Einsatz von Daten von Referenzstationen im Postprocessing möglich. Es befinden sich pro System etwa 30 Satelliten in einer bekannten Umlaufbahn. Durch an Bord befindlich Atomuhren können die Satelliten hochgenaue Zeitstempel und sich wiederholende Codemuster aussenden. Im Fall von Navstar GPS erfolgt die Aussendung aktuell auf drei verschiedenen Frequenzen L1, L2 und L5. Für die öffentliche Nutzung ist nur L1 freigegeben. L2 und L5 sind der militärischen Nutzung vorbehalten. Durch reine Auswertung des ausgesendeten L1-Codes können Genauigkeiten bis 5 Meter erreicht werden. Für geodätische Anwendungsfälle wird zusätzlich die Phasenmessung benutzt. Hierbei wird nicht nur das dem Funksignal aufmodelierte Codemuster ausgewertet, sondern auch die Phase des Signals. Hierdurch ist es auch möglich, dass verschlüsselte L2-Signal mitzunutzen. Durch die Nutzung von Referenzstationsnetzen wie SAPOS Genauigkeiten von 1-2cm in Echtzeit und von unter Zentimetergenauigkeit im Postprocessing erreicht werden \citep[S. 375]{Witte2006}.

\section{Inertiale Messeinheit}
\label{s:IMU}
Bei der Inertialen Messeinheit (inertial measurement unit, IMU) handelt es sich um einen Sensor, der die Neigung sowie Drehbewegungen der Sensoreinheit misst. Sie wird benötigt, um beim Airborne Laserscanning die genaue Ausrichtung des Laserscanners zu bestimmen. Daher muss diese auch unverwindbar mit dem Laserscanner verbunden sein. In Kombination mit den Positionsdaten des GNSS-Modules ermöglicht sie die Rekonstruktion der Flugbewegungen (Trajektorie). Ein weiterer Vorteil der intertialen Messeinheit ist ihre Messfrequenz: Im Gegensatz zum GNSS, dass im Normalfall nur eine Messung pro Sekunde durchführt, kann die IMU bis zu 200 Messungen pro Sekunde ausführen. Sie stützt daher nicht nur die GNSS-Messung sondern hilf auch, die Trajektorie zu interpolieren und somit auch für den Bereich zwischen den GNSS-Messungen genaue Positionen zu bestimmen. \citep[S. 23]{beraldin}

Hauptsächlich unterschieden werden die inertialen Messeinheiten in mechanische Systeme und MEMS-Systeme \todo{Quelle, ausformulieren}

\section{Kombination des Messsysteme}
Um die drei eigenständigen Messsysteme kombiniert nutzen zu können, muss die relative Position der Systeme genau bekannt sein und darf sich während des Fluges nicht verändern. Beim klassischen Airborne Laserscanning vom Helikopter werden hierfür zum Beispiel eigenständige Module entwickelt, die alle benötigten Systeme verdrehsicher enthalten und an den Kuffen des Helikopters montiert werden können \citep[S. 23f]{beraldin}

\chapter{Technische Realisierung}
\label{c:realisierung}

Wie bereits erwähnt soll das Airborne Laserscanning System von einem Multikopter getragen werden. Im Gegensatz anderen Versuchen dieser Art, soll es sich hierbei um einen Mini-Multikopter handeln mit einer Tragkraft von bis zu 5 Kilogramm. Ähnlich Sensorsysteme wurden bereits auf größen Plattformen realisiert, sind jedoch aufgrund ihrer Größe nur sehr begrenzt einsetzbar. \citep[S. 19]{uav}

\section {Verwendete Gerätschaften}

\subsection{Velodyne VLP-16}
\label{sss:vlp16}
Einer dieser Kompakt-Laserscanner ist der Velodyne Puck VLP-16 (siehe \autoref{img:vlp16}). Er bietet sich durch seine geringe Größe von nur etwa 10cm\todo{genau Größe} Durchmesser für den Einsatz an dem Multikopter an. Es handelt sich beim VLP-16 um einen um eine Achse rotierenden Scanner mit 16 Messstrahlen \citep{vlpSheet}. Der Scanner sendet diese Messstrahlen mit einer geringen Zeitdifferenz von \(2,3\mu s\) hintereinander aus, gefolgt von einer Nachladezeit von \(18,4\mu s\), so dass jeder Messstrahl alle \(55,3\mu s\) ausgesendet werden kann \citep[S. 16]{vlpManual}. Während der Messungen dreht sich der Laserscanner mit 5 bis 20 Umdrehungen pro Sekunde \citep{vlpSheet}. Pro ausgesendeten Strahl können jeweils der die erste und die stärkste Reflexion zurück gegeben werden, so dass über eine halbe Million Punkte pro Sekunde zurückgegeben werden können (siehe \autoref{equ:XproS}). Die Daten werden anschließend über den Netzwerkanschluss übertragen (siehe auch \autoref{ss:Datenlieferung}). Außerdem verfügt der Scanner über einen Anschluss für ein GNSS-Modul des Types Garmin GPS 18x LVC. Auch andere GNSS-Module sind nutzbar, so dass im Weiteren der Versuch unternommen wurde, hier das GNSS-Modul der Inertialen Messeinheit (siehe \autoref{s:iMar}) oder eines uBlox-GNSS-Modules zu nutzen (siehe \autoref{s:GNSSAnschluss}). Durch die Nutzung eines GNSS-Modules am Scanner ist es möglich, die Daten mit einem hochgenauen Zeitstempel zu versehen und die Messungen des Scanners so in der Nachbearbeitung mit den Daten aus der Inertialen Messeinheit zu verknüpfen.

\begin{equation}
 \label{equ:XproS}
 n = \frac{1s}{55,295\mu s} \cdot 16  \frac{Messstrahlen}{Messung} \cdot 2  \frac{Messwerte}{Messtrahl} = 578.714 \frac{Messwerte}{Sekunde}
\end{equation}

\begin{figure}[ht!]
 \centering
 \includegraphics[width=0.7\textwidth]{./img/vlp16.jpg}
 % vlp16.jpg: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{Laserscanner Velodyne VLP-16 (eigene Aufnahme)}
 \label{img:vlp16}
\end{figure}

\section{Inertiale Messeinheit und GNSS-Empfänger iMAR iNAT-M200-FLAT}
\label{s:iMar}
 Sie soll im Einsatz des Multikopters unverwindbar mit dem Laserscanner verbunden werden und so es ermöglichen, die Ausrichtung des Laserscanners zu bestimmen. Außerdem verfügt die verwendete Einheit über zwei differentielle Satellitennavigationsempfänger (GNSS-Module). Durch Postprocessing können diese eine Positionsgenauigkeit von etwa 2 Zentimeter erreichen \citep{imar}.\todo{alternativ: Matthias Wilkens} Durch die Verwendung von zwei Empfängern, die an jeweils einem Ausleger befestigt sind (siehe Bild \todo{Bild machen}), kann die Orientierung des Scanners bestimmt werden. Außerdem kann die Positionssicherheit durch Mittlung der beiden Positionen erhöht werden.

Im Postprocessing kann aus den Daten der Inertialen Messeinheit zusammen mit denen der GNSS-Module und GNSS-Korrekturdaten die Flugbahn des Multikopters berechnet werden. Die Daten der Inertialen Messeinheit werden hierbei regelmäßig durch die Daten der GNSS-Module gestützt.

\subsection{Raspberry Pi 3 Typ B}
\label{ss:Raspberry}
Es wurde sich entschieden, die Datenverarbeitung mit einem Raspberry Pi 3 durchzuführen. Es handelt sich hierbei um einen von der Raspberry Pi Foundation entwickelten Einplatinencomputer. Die Stiftung gründete sich 2006, um einen erschwinglichen Computer zu entwickeln, an den Schüler direkt Hardware- und Elektronikprojekte entwickeln können. Die erste Version des Raspberry Pi kam im Februar 2012 auf den Markt. Er verfügte über 256 MB Arbeitsspeicher und einen 700 MHz Ein-Kernprozessor. Das verwendete dritte Modell verfügt über einen Vier-Kern-Prozessor mit 1,2 Ghz und 1 GB Arbeitsspeicher. Bisher wurden alle Versionen zusammen über 11 Millionen mal verkauft. \citep{heise5Rasp}

Alle Modelle der Raspberry Pi Serie basieren auf Ein-Chip-System von des Halbleiterherstellers Broadcom. In diesem Chip sind die wichtigsten Bauteile des Systemes integriert wie ein ARM-Prozessor, eine Grafikeinheit sowie verschiedene andere Komponenten. Die so gering gehaltene Anzahl an einzelnen Bauelementen beim Raspberry Pi ermöglichen den geringen Preis - ein Ziel der Raspberry Pi Foundation.

Der Vorteil des Raspberry Pi zur Datenverarbeitung sind vor allem seine verschiedensten Schnittstellen zur Daten Ein- und Ausgabe \citep{raspSheet}:
\begin{itemize}
 \item 4 USB 2.0 Host-Anschlüsse
 \item Netzwerkschnittstelle (RJ45)
 \item Bluetooth- und WLAN
 \item 27 GPIO-Ports, nutzbar als \citep{ekRaspPin}
 \begin{itemize} 
  \item Digitale Pins
  \item Serielle Schnittstelle
  \item I2C-Schnittstelle
  \item SPI-Schnittstelle
 \end{itemize}
 \item Stromversorgung 3,3V und 5V
 \item MicroUSB-Anschluss zur eigenen Stromversorgung (5V)
 \item MicroSD-Steckplatz 
 \item verschiedene Video- und Audioausgänge
 \end{itemize}

Außerdem vorteilhaft ist für die Nutzung am Multikopter ist seine geringe 
Größe und sein relativ geringer Stromverbrauch von maximal 12,5 
Watt \citep{raspSheet}.

\subsection{Multikopter Copterproject CineStar 6HL}
Bei einem Multikopter handelt es sich um ein Fluggerät mit drei oder mehr Rotoren. Es gibt entsprechend der Rotoranzahl verschiedene Modelle wie zum Beispiel den weit verbreiteten Quadrokopter oder den Hexakopter, welcher in dieser Arbeit betrachtet wird. Multikopter wurden ursprünglich für Militär- und Polizeizwecke eingesetzt, inzwischen sind sie aber auch vermehrt in kleineren Ausführungen im Privatbesitz für Videoaufnahmen zu finden \citep{Quadro}. Angetrieben werden die handelsüblichen Modelle, welche eine Flugdauer von bis zu 30 Minuten und eine Tragkraft von bis zu fünf Kilogramm versprechen, mit Lithium-Polymer-Akkumulatoren (LiPo-Akkus). Die Anzahl und die maximale Umdrehung der Rotoren bestimmt die Schubkraft und somit auch die Tragkraft des Multikopters. Im Normalfall ist die Anzahl der Rotoren durch zwei teilbar, damit sich das auf das Traggestell wirkende Drehmoment aufhebt. Dies ist der große Vorteil gegenüber einem Hubschrauber, bei welchem mit einem Heckrotor dem Drehmoment um die Hochachse entgegengewirkt werden muss. Die einzelnen Motoren und Propeller werden kreuzweise angeordnet, so dass eine Drehzahländerung eines Propellerpaares zur Steuerung ausreicht. Vorteil eines Multikopters im Gegensatz zu einem Modellflugzeug ist es außerdem, dass er senkrecht starten kann und auch zum Beispiel für die Aufnahme von Bildern auf der Stelle stehen bleiben kann. Nachteil ist der höhere Energieverbrauch, so dass Flugzeuge bei gleicher Akkukapazität deutlich länger in der Luft bleiben können. \citep{Bachfeld}

In dieser Arbeit soll der Multikopter den Laserscanner, die IMU, das Gimbal, die Stromversorgung, Datenverarbeitung und -speicherung im Betrieb tragen können. Bei der Systementwicklung des Multikopters muss daher darauf geachtet werden, dass das Gewicht möglichst gering bleibt und dennoch müssen die angehängten Messeinrichtungen auch für härtere Landungen ausgelegt sein. Bei dem  verwendeten Hexakopter handelt es sich um einen  mit einer Tragkraft von etwa 5 Kilogramm und eine Flugdauer von bis zu 20 Minuten \citep{Schulz}.

\subsection{Gimbal Freefly MöVI M10}
Um die Messgeräte an dem Multikopter zu stabilisieren und zu verhindern, dass sich jede Neigung durch Flugsteuerung an den Laserscanner übertragen, wird ein sogenanntes Gimbal verwendet. Durch einen Regelkreis aus Motoren und einer inertialen Messeinheit (siehe auch \autoref{s:iMar}), werden Neigungen und Drehungen in Echtzeit ausgeglichen. Außerdem ist es durch viele Gimbals möglich, die Messtechnik unabhängig vom Multikopter auszurichten - dies ist zum Beispiel bei der Luftbildaufnahme wichtig.

Für das Projekt wird ein Gimbal des Herstellers Freefly verwendet. \todo{mehr...}


\section{Auswahl des Datenverarbeitungssystemes}

Ein Teil der Datenverarbeitung und die Speicherung soll direkt auf dem Sensorsystem durchgeführt werden. Da bei dem Betrieb des Multikopters jede weitere Masse die Laufzeit verkürzt, muss hierbei auf das Gewicht geachtet werden. Somit kommen für die Verarbeitung nur Ein-Chip-Computersysteme wie der Raspberry-Pi oder Mikrokontroller-Boards wie die der Arduino-Serie in Frage. 

Vorteile eines Arduinos wären vorallem der geringere Stromverbrauch und die Echt-Zeitfähigkeit. Jedoch ist die Steuerung der Datenaufnahme über die Netzwerkschnittstelle und die Speicherung deutlich komplizierter und die Hardware nicht so leistungsfähig. Bei der Alternative, dem Raspberry-Pi übernimmt das Betriebssystem die grundlegenden Steuerungen, so dass nur noch die Daten selbst verarbeitet werden müssen. Außerdem bietet er mit der festverbauten Netzwerkschnittstelle und dem MicroSD-Karten- und der USB-Schnittstelle auch die komplette benötigte Hardware, die so nicht einzeln zusammengestellt und -gebaut werden muss.


\section{Stromversorgung}
Die Stromversorgung des Raspberry-Pi an der Drohne soll mittels Lithium-Ionen-Zellen erfolgen. Der Raspberry-Pi erfordert hierbei eine stabilisierte Spannungs- und Stromversorgung. Eine fehlerhafte Stromversorgung kann hierbei zu Systeminstabilitäten führen und so im schlimmsten Fall die Datenaufzeichnung komplett verhindern. Auf den genauen Aufbau einer solchen Versorgung wird hierbei verzichtet, sondern nur die Anforderungen an die Energiequelle erläutert.

\todo{+IMU+Qc} 
\begin{table}
\begin{tabular}{ l | r | r | r | r }
  Gerät 	& Laserscanner	& IMU		& Raspberry-Pi\\
		& \citep{vlpSheet} &		& \citep{raspSheet}	\\
  \hline
  Spannung 	& 9 - 18 V 	&	12.0 V	& 5.0 V \\
  \hline
  max. Strom 	& 0.9 A		&		& 2.5 A \\
  \hline
  typ. Leistung	& 8 W		& 		& 12.5 W 
\end{tabular}
\caption{Spannungs- und Strombedarf der einzelnen Module}
\label{tab:strom}
\end{table}

\autoref{tab:strom} listet die verschiedenen Module und den die jeweils benötigte Energieversorgung auf. Der Multikopter mit der Gimbal verfügt über eine eigene Versorgung und muss daher nicht weiter beachtet werden. Außerdem hat hier eine eigene Akkukapazität auch Vorteile - auch bei einem zu hohen Verbrauch der Sensortechnik bleibt der Multikopter durch seine eigenständige Akku-Überwachung immer noch flugfähig um sicher landen zu können.

Für eine geplante Flugdauer von 30 Minuten wird bei einem angenommenen Wirkungsgrad von 90\% eine Akkukapazität von mindestens 12 Wh \todo{+IMU} (siehe \autoref{equ:akku}) benötigt. Außerdem muss ein Teil in 12 Volt und ein Teil mit 5V stabilisierter Spannung abgeben werden können. Gegebenenfalls sind hierfür auch zwei komplett unabhängige Spannungsquellen zu nutzen.

\todo{+IMU} 
\begin{equation}
\label{equ:akku}
E = \frac{ P \cdot t}{\eta} = \frac{(8W + 12.5W) \cdot 0,5h}{0,9} = 11,4 Wh
\end{equation}

\section{Anbindung des Raspberry Pi an den Laserscanner}
Durch seine vielseitigen Anschlussmöglichkeiten bildet der Raspberry Pi den Sternpunkt der Schnittstellen. Der Laserscanner wird mit einem RJ45-Kabel an der Netzwerkschnittstelle angeschlossen. Die Inertiale Messeinheit zeichnet die Daten selbstständig auf, kann aber auch mittels der als serieller Schnittstelle nutzbaren GPIO-Pins an den Raspberry angeschlossen werden. Außerdem kann an diesem Port auch ein GNSS-Modul angeschlossen werden. Dieses GNSS-Modul kann im folgenden dem Raspberry Pi zu einer genauen Uhrzeit verhelfen, die für die Verarbeitung der Daten benötigt wird. Alternativ kann auch ein an den Laserscanner angeschlossenes GNSS-Modul sein Zeitstempel per Netzwerk an den Raspberry Pi liefern. Diese Methode soll hier verwendet werden.

\section{Verbindung des GNSS-Modules zum Laserscanner}
\label{s:GNSSAnschluss}
Die Übertragung der Daten des GNSS-Modules zum Laserscanner erfolgt per serieller Schnittstelle über einen acht poligen Platinensteckverbinder. Bei dem vom Laserscanner benötigten Übertragungsprotokoll handelt es sich um das standardisierte NMEA-Protokoll, welches mit einer Datenrate von 9600bit/s und einer Signalspannung zwischen 3 und 15 Volt. Der direkte Anschluss eines uBlox GNSS-Modules vom Typ NEO-6M brachte zunächst keinen Erfolg. Messungen mit einem Ardunio (siehe \autoref{abb:oszi}) zeigten, dass das Signal des verwendeteten GNSS-Moduls nicht dem im Datenblatt von \citet[S. 3]{vlpInterface} entsprach. Es zeigte sich, dass das Signal gedreht werden musste, da die Definition der Signalspannung verschieden war: Der Laserscanner benötigte ein Signal, bei dem Logisch 1 mit einer Spannung von über 3 Volt \citep[S. 3]{vlpInterface} codiert ist (HIGH), beim GNSS-Modul entspricht  die höhere Spannung Logisch 0.

\begin{figure}[ht!]
 \centering
 \includegraphics[width=0.7\textwidth]{img/oszi.png}
 % GNSS-Modul_Schaltplan_Entwurf.svg: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{Messung des Signals am uBlox NEO-6M (grün: Ausgangssignal; rot: Signal nach Nutzung eines Pegelwandler; 1000 Punkte entsprechen 5 Volt)}
 \label{abb:oszi}
\end{figure}

Um das Signal zu drehen wurde ein Integrierter Schaltkreis 74HC04 verwendet. Hierbei handelt es sich um ein Logikkonverter, der die HIGH- und LOW-Signale (Signal gegen Masse) tauscht. Der Laserscanner versorgt das GNSS-Modull nur mit 5 Volt Spannung, der GNSS-Chip benötigt jedoch eine Spannung von 3,3 Volt. Hierfür wurde ein Spannungsregler verwendet, der die Spannung auf 3,3 Volt stabilisiert. Zur weiteren Stabilisierung wurden Kondensatoren eingesetzt. In Kombination mit dem Logikkonverter dient dieser auch als Pegelwandler. Die genaue Schaltung ist \autoref{abb:schaltplan} zu entnehmen.

\begin{figure}[ht!]
 \centering
 \includegraphics[width=0.7\textwidth]{img/GPS_Schaltung.pdf}
 % GNSS-Modul_Schaltplan_Entwurf.svg: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{Schaltplan zum Anschluss des GNSS-Modules an den Laserscanner, gezeichnet in Fritzing}
 \label{abb:schaltplan}
\end{figure}

\section{Steuerung im Betrieb}
\label{s:steuermodul}
Der Betrieb des Raspberry Pi erfolgt im Betrieb ohne Tastatur und Bildschirm. Daher ist es notwendig, eine alternative Benutzerschnittstelle zu implementieren. Ein großer Steuerbedarf ist nicht gegeben, so dass wenige Tasten zum Stoppen der Datenaufzeichung und zum Herunterfahren des Raspberry Pi ausreichend sind. Um auch eine Steuermöglichkeit zu implementieren, die im Flug genutzt werden kann, soll ein WLAN-Access-Point und ein simpler Webserver auf dem Raspberry Pi implementiert werden, der den Zugriff zum Beispiel über ein Smartphone oder Laptop ermöglicht.

\begin{figure}[ht!]
 \centering
 \includegraphics[width=0.7\textwidth]{img/steuerung.pdf}
 % GNSS-Modul_Schaltplan_Entwurf.svg: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{Schaltplan für Steuerung des Raspberry, gezeichnet in Fritzing}
 \label{abb:steuerung}
\end{figure}

\autoref{abb:steuerung} zeigt den Schaltplan des entwickelten Steuermodules. Dieses bietet mit drei Leuchtdioden und 2 Tastern die Möglichkeit, im Skript später einfache Anzeigen und Eingaben zu realisieren. Hierfür wurde eine Erweiterung auf Basis des GPIO-Portes des Raspberry Pi aufgebaut. Die zwei Taster sind über die beiden GPIO-Pins \todo{PinNummer} erreichbar. Ohne Betätigung werden die Eingänge über die Pull-Down-Widerstände (\todo{R?}) auf ein Low-Level gezogen. Durch Drücken des Tasters wird ein High-Signal erzeugt, welches durch das Pythonskript zur Laufzeit ausgelesen werden kann. Der Widerstand \todo{R?} dient zur Strombegrenzung.
Die drei Leuchtdioden wurden mit jeweils einem 150Ohm Vorwiderstand direkt zwischen ein GPIO-Pin und Ground eingebaut. Durch Ansteuerung der GPIO-Pins lassen sich diese An- und Abschalten. Außer zum Schutz und Betrieb der LEDs verhindern die Vorwiderstände auch eine zu hohe Stromaufnahme aus den GPIO-Pins. Die genaue Belastbarkeit der Pins ist nicht dokumentiert, jedoch wird meist von einem Wert um 10mA bei 3,3 Volt gesprochen (zum Beispiel \citet{ekRaspPin}).

\begin{equation}
\begin{aligned}
U_R &= U_{GPIO} - U_{LED} = 3,3V - 2,0V = 1,3V    && \left|\  \text{Benötigter Spannungsabfall} \right. \\
R &= \frac{U_R}{I_{LED}} = \frac{1,3V}{0,01A} = 130\Omega   && \left|\  \text{min. Vorwiderstand} \right. \\
\end{aligned}
\label{eq:vorwiderstand}
\end{equation}

\section{Platinenentwurf und -realisierung}
Nach dem Entwurf und Test der beiden Schaltungen aus \autoref{abb:schaltplan} und \autoref{abb:steuerung} auf einem lötfreien Steckbrett, soll diese Schaltungen zum späteren Einsatz an Bord des Multikopters als Platine mit verlöteten Bauteilen erstellt werden. Vorteile der gelöteten Schaltung sind in diesem Projekt ihre höhere Widerstandsfähigkeit gegen Vibrationen und Korrosion. Durch die Vibrationen im Flug könnten sich so Bauteile lösen und im schlimmsten Fall zum Kurzschluss und somit zur Zerstörung führen. Auch können die Kontakte zwischen den Federklemmen und den Bauteilen durch den Betrieb außerhalb von Gebäuden durch Luftfeuchtigkeit korrodieren und somit der Kontaktwiderstand höher werden, was zu Störungen führen kann.

Für den Prototyp soll die Schaltung von Hand aufgebaut und verlötet werden. Erst in der zukünftigen Entwicklung, wenn die Schaltung ausreichend erprobt wurde, könnte es sinnvoll sein, eine Platine ätzen zu lassen. Als Platine kommen daher vorerst nur vorgefertigte Layouts in Frage:

\begin{itemize}
 \item Lochrasterplatinen (Platine mit einzelnen Lötpunkten)
 \item Streifenrasterplatine (Lötpunkte sind in Streifen verbunden)
 \item Punktstreifenrasterplatine (Streifenrasterplatine, bei denen die Streifen regelmäßig, zum Beispiel alle 4 Lötpunkte, unterbrochen sind)
 \item spezielle Aufsteckplatinen für den Raspberry Pi
\end{itemize}



\chapter{Theoretische Datenverarbeitung}
\label{c:datenverarbeitung}

\section{Verwendung von Python}
Zur Realisierung der Programmierung wurde die Sktiptsprache Python ausgewählt. Python bietet den Vorteil vergleichsweise kurzen und gut lesbaren Programmierstil zu fördern. Hierfür werden unter anderem nicht Klammern zur Bildung von Blöcken genutzt sondern Texteinrückungen verplichtend hierfür eingesetzt \citep[S. 13f]{python}. Die Struktur des Programmes ist so schnell erfassbar. Außerdem ist es nicht notwendig, den Quellcode zu kompilieren. Er wird vom Interpreter direkt ausgeführt. So sind kurze Entwicklungszyklen ohne (zeit-)aufwändiges Kompilieren möglich. Änderungen und Anpassungen können schnell durchgeführt werden.

Python wurde in seiner ersten Version 1991 von Guido van Rossum freigegeben. Sein Ziel war es, eine einfach zu erlernende Programmiersprache zu entwickeln, die der Nachfolger der Sprache ABC werden sollte. Außerdem sollte die Sprache leicht erweiterbar sein und schon von Haus aus eine umfangreiche Standardbibliothek bieten. Python bietet mehrere Programmierparadigmen an, so dass je nach zu lösenden Problem objektorientiert oder strukturiert programmiert werden kann \citep[S. 14]{python}.

Die aktuelle Version von Python (Oktober 2017) ist die Version 3.6. Das Skript wurde unter Verwendung dieser Version entwickelt. Es wurde aber auch auf eine Kompatibilität mit Python 2.7, der neusten Version von Python 2, die noch sehr häufig im Einsatz ist, geachtet. Um Teile des Quellcodes als Python-Module auch in andere Skripte einfach einbinden zu können, aber auch den Quelltext übersichtlich zu halten, wurde der objektorientierte Programmierstil gewählt.

\section{Datenlieferung vom Laserscanner}
\label{ss:Datenlieferung}
Der Laserscanner Velodyne VLP-16 liefert seine Daten als UDP-Netzwerkpakete in einem proprietären binären Datenformat. Diese Daten sind nicht direkt lesbar sondern müssen vor einer weiteren Nutzung aufbereitet und umgeformt werden. Dies soll mittels des in dieser Arbeit entwickelten Scriptes durchgeführt werden.

Ein Datenpaket (siehe \autoref{tab:datenmodell}) besteht jeweils aus einem Header von 42 Bytes, gefolgt von 12 Datenblöcken mit jeweils 32 Messungen, abgeschlossen von 4 Bytes, die den Zeitstempel angeben und 2 Bytes, die den eingestellten Scan-Modus zurückliefern. Jeder Datenblock enthält die aktuelle horizontale Ausrichtung des rotierenden Lasers und darauf folgend die Messwerte von zwei Messungen der 16 Laserstrahlen. Die genaue Horizontalrichtung zum Zeitpunkt der Messung muss aus den Horizontalrichtungen aus zwei auf einander folgenden Messungen interpoliert werden.

\begin{table}[!ht]
\centering
\begin{tabular}{|lll|l|l|}
\hline
Header                                         &                                 
                &           & Netzwerk-Header  & 42 Bytes \\ \hline
\multicolumn{1}{|l|}{\multirow{7}{*}{Block 1}} &                                 
                & 0-1       & Flag             & 2 Bytes  \\ \cline{2-5} 
\multicolumn{1}{|l|}{}                         &                                 
                & 2-3       & Horizontalwinkel & 2 Bytes  \\ \cline{2-5} 
\multicolumn{1}{|l|}{}                         & 
\multicolumn{1}{l|}{\multirow{2}{*}{Messung 1}} & 4-5       & Entfernung       & 
2 Bytes  \\ \cline{3-5} 
\multicolumn{1}{|l|}{}                         & \multicolumn{1}{l|}{}           
                & 6         & Reflektivität    & 1 Byte   \\ \cline{2-5} 
\multicolumn{1}{|l|}{}                         & 
\multicolumn{1}{l|}{\multirow{2}{*}{Messung 2}} & 7-8       & Entfernung       & 
2 Bytes  \\ \cline{3-5} 
\multicolumn{1}{|l|}{}                         & \multicolumn{1}{l|}{}           
                & 9         & Reflektivtät     & 1 Byte   \\ \cline{2-5} 
\multicolumn{1}{|l|}{}                         & \multicolumn{4}{l|}{Messungen 3 
- 32}                                                     \\ \hline
\multicolumn{5}{|l|}{Block 2 - 12}                                               
                                                          \\ \hline
Time                                           & \multicolumn{1}{l|}{}           
                & 1200-1204 & Zeitstempel      & 4 Bytes  \\ \hline
Factory                                        & \multicolumn{1}{l|}{}           
                & 1205-1206 & Return-Modus     & 2 Bytes  \\ \hline
\end{tabular}

\caption{Aufbau der Daten des Netzwerkpaketes, nach \citet{vlpManual}}
\label{tab:datenmodell}
\end{table}

Der Laserscanner sendet bei der Einstellung Dual Return, also der Rückgabe vom stärksten und letzten Signal pro Messung 
bis zu 1508 Pakete dieser Form pro Sekunde \citep[S. 49]{vlpManual}. Die Ausgangsdaten werden, bei einer Paketgröße von 1248 Bytes mit einer Datenrate von 1,8 MB/s empfangen (siehe \autoref{equ:Ausgangsrate}). Hierbei werden fast 600.000 Messwerte pro Sekunde übertragen (siehe \autoref{equ:MessungenPS}).

\begin{equation}
 \frac{1508 Pakete}{Sekunde} \cdot \frac{12 Datenbloecke}{Paket} \cdot
\frac{32 Messungen}{Datenblock} = \frac{579.072 Datensaetze}{Sekunde}
 \label{equ:MessungenPS}
\end{equation}

\begin{equation}
 \frac{1508 Pakete}{Sekunde} \cdot \frac{1248 Bytes}{Paket} = 1,79 MB/s
 \label{equ:Ausgangsrate}
\end{equation}

\section{Geplantes Datenmodell}
\label{s:datenmodell}
Die Daten des Laserscanners sollen in einer einfach lesbaren Textdatei abgelegt werden. In der Nachbereitung sollen die Daten aus dieser Textdatei mit den Daten der Inertialen Messeinheit und des GNSS-Empfängers verknüpft werden, um so die Daten georeferenzieren zu können. Als Verknüpfung bietet sich hier der Zeitstempel an. Die Inertialen Messeinheit und der Laserscanner können hierbei die Zeitdaten aus dem GNSS-Signal verwenden. Hierdurch sind hochgenaue Zeitstempel möglich. Die Zeitinformation bildet also einen wichtigen Schlüssel in den Daten. Als einfaches Textformat wurden durch Tabulator getrennte Daten, jeweils eine Zeile je Messung, gewählt. Folgende Daten sind in dieser Reihenfolge enthalten:

\begin{itemize}
 \item Zeitstempel in Mikrosekunden
 \item Richtung der Messung in der Rotationsebene in Grad
 \item Höhenwinkel zur Rotationsebene in Grad
 \item Gemessene Entfernung in m
 \item Reflektivität auf einer Skala von 0 bis 255
\end{itemize}

Problematisch ist bei diesem Datenmodell jedoch die benötigte Datenrate. Eine Datenzeile erfordert 29 Bytes und somit wird bei über einer halben Million Messungen pro Sekunde (siehe \autoref{equ:MessungenPS}) eine Datenschreibrate von mindestens 16 MB/s benötigt (siehe \autoref{equ:Datenrate}). Da das Schreiben nicht dauerhaft erfolgt, sollte die Datenrate bevorzugt deutlich höher sein.

\begin{equation}
 \frac{579.072 Datensaetze}{Sekunde} * \frac{29 Bytes}{Datenzeile} = 16,02 MB/s
\label{equ:Datenrate}
\end{equation}

Erste Test ergaben, dass diese Verarbeitungsgeschwindigkeit nicht mit dem Raspberry Pi erreicht werden konnte. Außerdem benötigen die Daten sehr viel Speicher. Daher wurde sich später für eine Hybridlösung entschieden (siehe \autoref{c:skript}).

\section{Weiterverarbeitung der Daten zu Koordinaten}
Die als Text gespeicherten Rohdaten sollen dann im Rahmen einer weiterführenden Arbeit zu Koordinaten umgewandelt werden. Zu dieser Umwandlung werden die Positionen des Laserscanners mittels dem GNSS-Empfänger in der IMU und die Neigungsdaten aus der IMU verwendet. Die Neigungen werden dazu direkt mit den Winkeldaten verrechnet.

Bei der Berechnung ist jedoch zu beachten, dass der Ursprungspunkt der Laserstrahlen nicht in der Drehachse des Laserscanners liegt, sondern etwa 40mm in Strahlrichtung verschoben ist (siehe \autoref{img:strahlengang}). Bei der Streckenberechnung ist diese Strecke mit enthalten, jedoch ist diese Entfernung für die Nutzung des Höhenwinkels des Laserscanners entscheidend, wenn auch diese Abweichung für den Einsatzzweck zur Erzeugung eines digitalen Geländemodelles nur von geringerer Bedeutung ist.\todo{Satz sortieren}

\begin{figure}[ht!]
 \centering
 \includegraphics[width=0.7\textwidth]{./img/Strahlengang.png}
 % Strahlengang.eps: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=0 0 3066 4000
 \caption{Strahlengang im Laserscanner VLP-16, Werte in Millimetern, nach 
\citet{vlpCAD}}
 \label{img:strahlengang}
\end{figure}

\section{Anforderungen an das Skript}
Aus den technischen Vorgaben ergeben sich dann folgende Funktionen, die das Skript aufweisen muss:
\begin{itemize}
 \item Rohdaten vom Scanner abrufen
 \item Zeit vom GNSS-Modul abrufen
 \item Steuerungmöglichkeit mittels Hard- und Software
 \item Umwandlung in eigenes Datenmodell
\end{itemize}

Der Ablauf der einzelnen Schritte ist oft abhängig vom Fortschritt anderer Schritte und Gegebenheiten. Daher wurden die benötigten, einzelnen Schritte vorerst als grober Ablaufplan skizziert. So hat der Raspberry Pi keinen eigenen Zeitgeber. Um die Dateien aber mit dem korrekten Zeitstempel zu versehen, ist daher eine aktuelle Uhrzeit notwendig - diese liefert das GNSS-Modul, welches am Laserscanner angeschlossen ist, sofern ein GNSS-Fix besteht. Es muss also vor dem Erzeugen der Dateien auf ein gültiges GNSS-Signal gewartet werden. Der endgültige, vereinfachte Ablaufplan ist der \autoref{img:ablaufplan} zu entnehmen. 
\begin{figure}[ht!]
 \centering
 \includegraphics[width=0.8\textwidth]{./img/Ablaufplan.png}
 % Strahlengang.eps: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=0 0 3066 4000
 \caption{Vereinfachter Ablaufplan des Skriptes}
 \label{img:ablaufplan}
\end{figure}

\chapter{Entwicklung des Skriptes}
\label{c:skript}

\section{Klassenentwurf}
Da das Skript objektorientiert programmiert werden soll, wurde zunächst mit Hilfe des Ablaufplanes aus \autoref{img:ablaufplan} die benötigten Klassen entworfen. Die endgültigen Klassen sind der \autoref{img:uml} zu entnehmen. Auf die genauen Funktionen der einzelnen Klassen wird im Abschnitt \todo{Verlinken} eingegangen.

\begin{figure}[ht!]
 \centering
 \includegraphics[width=0.8\textwidth]{./img/UML.png}
 % Strahlengang.eps: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=0 0 3066 4000
 \caption{UML-Klassendiagramm}
 \label{img:uml}
\end{figure}

\section{Evaluation einzelner Methoden}
Um eine einfache Fehlersuche zu ermöglichen, wurde die grundlegenden Funktionen in einzelnen Skripte entwickelt und geprüft. Diese kleineren Skripte haben den Vorteil, Fehler schneller eingrenzen zu können und auch schon früh konzeptionelle Fehler zu entdecken. In diesem Schritt wurde bemerkt, dass das ein großes Problem die Geschwindigkeit der Datenverarbeitung ist. 

\paragraph{Datenempfang}
Die Verbindung zum Laserscanner mittels Python-Socket funktionierte ohne weitere Probleme. Die binären Daten konnten zeitgleich abgespeichert werden.

\paragraph{Datentransformation}
Zunächst war es geplant, die Daten direkt in das in \autoref{s:datenmodell} vorgestellte Datenmodell umzuformen. Hierzu sollte der Empfang der Daten direkt eine Umformmethode starten. Die Versuche erfolgten zunächst mit dem im vorherigen Test aufgezeichneten Daten. Schon hier zeigte sich, dass die Umwandlung der aufgezeichneten Daten etwa die fünffache Zeit als für deren Messung und Aufzeichnung benötigt wurde beanspruchte. Wie erwartet, brachte auch das direkte Einlesen der Daten vom Scanner keinen Erfolg. Es folgte ein Überlauf des Netzwerk-Buffer und somit der Verlust von Messdaten. Grund hierfür war hauptsächlich die benötigte Prozessorzeit. Die Nutzung einer schnelleren Datenspeicherung auf einer Solid-State-Disk mit einer Schreibrate von bis zu 300 MB/Sekunde änderte nichts an der Geschwindigkeit des Skriptes. Auch das Erzeugen eines neuen Threads für jeden empfangenen Datensatz war nicht erfolgsversprechend, da bis zu 1500 Threads pro Sekunde hierdurch gestartet wurden und das gesamte System überlastet wurde. Die Umformung musste daher von dem Datenempfang entkoppelt werden und das Skript für die Nutzung von Mehrkernprozessoren optimiert werden. Threads in Python laufen dennoch in einem Prozess und somit nur auf einem Prozessor. Es wurde das in \autoref{s:multikern} vorgestellte Multikern-Konzept erarbeitet.

\paragraph{Hardware-Steuerung}
Ein Tastendruck auf dem Steuerungsmodul (siehe \autoref{s:steuermodul}) sollte den Raspberry Pi zum Beispiel herunterfahren. Auch dieses Skript wurde getestet. Ein Problem hierbei war es, dass das Skript Administratorrechte (\code{root}) benötigte, um den Rechner herunterfahren zu können. Hierfür wurde jedoch eine Lösung gefunden, indem dem Nutzer \code{pi} die entsprechenden Rechte zum Herunterfahren gegeben wurden (siehe \autoref{s:root}). Eher zufällig zeigte sich aber noch ein anderes Problem: Sofern das Skript im automatisch mit dem Start des Raspberry Pi gestartet wurde und das Steuermodul nicht angeschlossen war, fuhr der Raspberry Pi automatisch nach wenigen Sekunden Betrieb herunter. Da mit dem fehlenden Modul auch die Pull-Down-Widerstände fehlten, war der GPIO-Pin auf einem nicht definierten Zustand. Es kam dazu, dass er zufällig auf einem HIGH-Niveau war, welches als Drücken des Tasters interpretiert wurde. Nach Überschreiten der konfigurierten Haltezeit des Ausschalters von zwei Sekunden, wurde der Herunterfahrprozess gestartet. Um dieses Problem zu unterdrücken, wurde dem Skript eine vorherige Abfrage hinzugefügt, die beim Start überprüft, ob die beiden Taster auf einem Low-Niveau sich befinden, dass durch die beiden angeschlossenen Pull-Down-Widerstände erreicht wird. Falls dieses nicht der Fall ist, beendet sich die Hardwaresteuerung selbstständig.

\section{Multikern-Verarbeitung der Daten}
\label{s:multikern}
Da bei der Evaluation der einzelnen Methode herausgefunden wurde, dass die Verarbeitungsgeschwindigkeit des Raspberry Pi für eine sofortige Transformation der Daten nach deren Eingang zu langsam ist, wurde ein Konzept erarbeitet, den hierdurch auftretenden Messdatenverlust zu unterdrücken.

Der Verarbeitung musste ein weiterer Buffer vorgeschaltet werden. Da aber das Abschalten des Raspberry Pi, zum Beispiel durch einen Verlust der Energieversorgung, nicht zu Datenverlusten führen sollte, konnten nicht die in Python integrierten Funktionen zur Datenzwischenspeicherung verwendet werden -- diese setzen zur Zwischenspeicherung auf den Arbeitsspeicher, der durch Stromverlust gelöscht wird. Das dauerhafte Schreiben auf die Festplatte -- im Fall des Raspberry Pi einer MicroSD-Speicherkarte -- fuhrt aber zur weiteren Verlangsamerung. Es wurde daher eine Hybridlösung erarbeitet.

Die Arbeit wird nun auf mehrere Prozesse verteilt:
\begin{itemize}
 \item Start des Skriptes und Gesamtsteuerung in Prozess mit mittlerer Priorität (Klasse \code{VdAutoStart}, mit Threads für Weboberfläche (Methode \code{startWeb() in Klasse \code{VdAutoStart}} und Hardwaresteuerung (Klasse \code{VdHardware})
 \item Sammeln der Daten mit höchster Priorität (Klasse \code{VdBuffer})
 \item Umformen der Daten durch mehrere Prozesse je nach Prozessorkernanzahl mit erhöhter Priorität (Klasse \code{VdTransformer})
\end{itemize}

Die Daten werden nun zuerst für wenige Sekunden im Arbeitsspeicher gesammelt. Sofern 7.500 Datensätze zwischengespeichert wurden -- je nach Einstellung des Laserscanners in etwa fünf oder zehn Sekunden -- werden diese im Dateisystem als binäre Datei abgelegt und der Dateiname in einer Warteschlange aus dem \code{multiprocessing}-Modul von Python (Klasse \code{Queue}) abgelegt. Die Prozesse zum Umformen der Daten fragen diese Warteschlange nun ab, verarbeiten jeweils eine binäre Datei und hängen die Ergebnisse an eine Ergebnis-Textdatei an. Die Dateinamen der binäre Dateien, dessen Bearbeitung begonnen wurde, werden aus der Warteschlange entfernt. Nach dem Schreiben der umgeformten Daten werden die binären Dateien aus dem Dateisystem entfernt. Damit die Umformer-Prozesse beim Schreiben nicht auf einander warten müssen, schreibt jeder Prozess in eine andere Ergebnisdatei. Diese können nach der Messung einfach zusammengefügt werden. Falls nun zum Beispiel die Stromversorgung unterbrochen wird, sind nur die Daten der maximal letzten 10 Sekunden verloren. Daten, die älter sind, sind entweder als binäre Daten oder als Textdatei gespeichert. Durch neues Starten des Umformerprozesses können die restlichen, noch nicht gewandelten Daten umgeformt werden.

Durch diese Prinzip stört eine stockende Datenumformung nicht das Aufzeichnen der Daten vom Scanner. Sofern der Raspberry Pi nicht die Geschwindigkeit der Umformung halten kann, werden einfach mehr binäre Dateien zwischengespeichert, die gegebenenfalls im Postprocessing umgewandelt werden können.

\section{Klassen}
Es folgt die Beschreibung der einzelnen Klassen. Auf die Konstruktor-Methoden \code{\_\_init\_\_()} wird nicht eingegangen, da hier meist nur Variablen deklariert werden.

\subsection{VdAutoStart}
Die Klasse mit dem Namen \code{VdAutoStart} (siehe Anhang~\ref{a:vdAutoStart.py}) steuert den automatischen Start des Skriptes beim Hochfahren des Raspberry Pi. Sie ist verantwortlich für den korrekten Start der einzelnen Skriptteile in der richten Reihenfolge. Außerdem sind in der zugehörigen Datei auch alle Programmteile abgelegt, die nicht zu einer Klasse gehören, wie zum Beispiel der Startaufruf.

Zu Beginn wird geprüft, auf welcher Umgebung das Skript läuft. Sofern es auf einem Raspberry Pi läuft, werden später zusätzliche Klassen aufgerufen.

\paragraph{run()}
Das Skript startet mit dieser Methode. Als erstes wird die Hardwaresteuerung in einem neuen Thread aktiviert, sofern es sich bei der Umgebung um einen Raspberry Pi handelt und die entsprechenden Module zur Steuerung der GPIO-Pins installiert sind. Sofern auf ein GNSS-Fix zur Einstellung der Uhrzeit gewartet werden soll, wird zunächst die Methode \code{getGNSSTime()} der Klasse \code{VdInterface} aufgerufen. Außerdem wird der für die zu speichernden Daten genutzte Ordner angelegt.

Folgend wird ein Prozess der Klasse Buffer gestartet. Um eine Kommunikation zu diesem neuen Prozess zu ermöglichen, werden einige Pipes und eine Warteschlange (Queue) mit an den neuen Prozess übergeben.

Sofern die Daten simultan transformiert werden sollen, wird abgefragt, wie viele Prozessoren dem System zur Verfügung stehen und eine entsprechende Anzahl an Transformer-Prozessen gestartet (n - 1, mindestens 1). Auch hier werden zur Kommunikation Pipes und die Queue verwendet.

\paragraph{aufzeichnungStarten()}
Die Methode startet den Buffer-Vorgang des VdBuffer-Prozesses. Sie wird durch die Steuersysteme aufgerufen.

\paragraph{aufzeichnungStoppen()}
Diese Methode stoppt die Aufzeichnung durch den VdBuffer-Prozess und wird auch durch die Steuersysteme genutzt.

\paragraph{herunterFahren()}
Ermöglicht den Steuersystemen, dass die VdBuffer- und VdTransformer-Prozesse zu unterbrechen und das System herunterzufahren.

\paragraph{\_\_main\_\_()}
Die Methode \code{\_\_main\_\_()} gehört nicht zu der Klasse sondern ist nur mit in dieser Datei abgelegt. Sie erzeugt ein Objekt der Klasse \code{VdAutoStart} und startet die \code{run()}-Methode. Außerdem wird die Weboberfläche hieraus gestartet.

\paragraph{Flask-Webinterface app}
Die Weboberfläche zur Steuerung wird mit dem Modul \code{Flask} erzeugt. Die Weboberfläche wird durch die main-Methode in einem zusätzlichen Thread gestartet.

\subsection{VdInterface}
Die Klasse \code{VdInterface} (siehe Anhang~\ref{a:vdInterface.py}) übernimmt die Kommunikation mit dem Laserscanner.

\paragraph{getDataStream()}
DIe Methode öffnet den Netzwerk-Stream, der die Messdaten des Laserscanners überträgt. Das Auslesen der Daten aus dem Stream erfolgt dann in der Klasse \code{VdBuffer}.

\paragraph{getGNSSStream()}
Durch die Methode wird der Netzwerkstream geöffnet, der die aktuellen Datensätze des an den Laserscanner angeschlossenen GNSS-Modules überträgt. Aus den Daten kann zum Beispiel die Uhrzeit gewonnen werden.

\paragraph{getStream()}
Da die benötigten Schritte zum Öffnen der beiden vorher vorgestellten Streams identisch sind, wurden diese Funktionalitäten in diese Methode ausgelagert, um den Code möglichst redundanzfrei zu halten.

\paragraph{getGNSSTime()}
Diese Methode fragt die Daten, die über den GNSS-Netzwerkstream geliefert werden, solange ab, bis der NMEA-Datensatz eine GPRMC-Nachricht mit einem GNSS-Fix, also einer gültigen Position, enthält. Diese Nachricht enthält außer der aktuellen Position und dem GNSS-Fix-Status auch den aktuellen Datums- und Zeitstempel. Die erkannte Uhrzeit wird als Python-timestamp an die Methode \code{setSystemZeit()} weitergegeben.

\paragraph{setSystemZeit()}
Die Methode setzt die aktuelle Systemzeit auf Basis eines ihr übergebenen Zeitstempels. Hierzu werden Befehle des Linuxbetriebssystemes angesprochen, dessen Verwendung vorher freigegeben werden muss (siehe \autoref{s:root}). Zuerst wird die Netzwerk-Zeitsynchronisierung abgeschaltet, dann die Uhrzeit gesetzt und die Synchronisierung wieder aktiviert. Die Deaktivierung ist notwendig, da ansonsten Linux keine Änderung an der Uhrzeit erlaubt. Eine komplette Deaktivierung der Netzwerk-Zeitsynchronisierung ist nicht zu empfehlen, da so die Uhr immer manuell gestellt werden muss.

\subsection{VdHardware}



\section{Beispiel-Quelltext-Zitat}

Die Daten werden eingelesen (siehe Zeile 18, \autoref{pySource})

\lstinputlisting[language=Python, firstnumber=15, caption={Quelltext-Test}, label=pySource, firstline=15, lastline=20]{../Quelltext/vdFile.py}


\chapter{Konfiguration des Raspberry Pi}
\label{c:konfig}

Als Grundlage wurde auf die MicroSD-Karte, die dem Raspberry Pi als Festplatte dient, das Betriebssystem Raspbian aufgespielt. Hierbei handelt es sich um ein Derivat von Debian GNU/Linux, das speziell auf die Hardware des Raspberry Pi angepasst wurde. Die aktuelle Version (Stand 27.10.2017) nennt sich Raspian Stretch. Für die Verwendung als Verarbeitungsgerät ohne angeschlossenen Display reicht die Variante ohne grafische Benutzeroberfläche aus (Raspbian Stretch Lite). Die Konfiguration des Raspberry Pi erfolgt vollständig über Konfigurationsdateien. In dieser Arbeit erfolgte die Konfiguration per Fernzugriff über SSH, einem Standard für das Fernsteuern der Konsole über das Netzwerk. Eine Konfiguration hätte aber auch mittels einem angeschlossenen Display und einer USB-Tastatur erfolgen können.

Die Änderungen der Konfigurationsdateien erfolgte mit vorinstallierten Editor \code{nano} unter Nutzung der Administratorrechte. Ein solcher Aufruf erfolgt zum Beispiel mit dem Befehl \code{sudo nano /pfad/zur/konfiguration.txt}. Nachfolgend müssen die betroffenen Programme oder sogar das komplette Betriebssystem neugestartet werden. Der Neustart eines Services erfolgt zum Beispiel mit dem Aufruf \code{sudo service programmname restart}, der Neustart des Betriebssystemes mit \code{sudo shutdown -r now}. Es empfiehlt sich, von allen zu ändernden Konfigurationsdateien Sicherungskopien anzulegen. Dies erfolgt zum Beispiel mit \code{sudo cp original.txt original.old.txt} (Kopieren) oder \code{sudo mv original.txt original.old.txt} (Verschieben, zum Beispiel zum Anlegen einer komplett neuen Datei). Auf diese Linux-Grundlagen wird im folgenden nicht mehr eingegangen.

\section{Installation von Raspbian}
Die Installation von Raspbian erfolgt durch das Entpacken des Installationspaketes von der Website der Raspberry Pi Foundation auf einer leeren MicroSD-Karte mit dem Tool \code{Etcher}. Auf der nach dem Entpacken erzeugten boot-Partition wird eine leere Datei mit dem Namen \code{ssh} angelegt. Hierdurch wird sofort nach dem Start der SSH-Zugang über das Netzwerk zum Raspberry Pi ermöglicht, die IP-Adresse wird per DHCP, zum Beispiel von einem im Netzwerk vorhandenen Router, bezogen. Nach dem Einloggen zum Beispiel unter Linux mit dem Befehl \code{ssh pi@raspberrypi} und dem Passwort \code{raspberry}, kann mittels \code{passwd} das Passwort verändert werden.

% HafenCity

\section{Befehle mit Root-Rechten}
\label{s:root}
Linux erlaubt das Ändern der Zeit und das Herunterfahren über die Kommandozeile nur dem Administrator (\code{root}). Da es jedoch nicht empfohlen ist, Skripte als \code{root} auszuführen, muss hier eine andere Lösung gefunden werden, um den Skripten die Möglichkeit zu geben, den Raspberry Pi auf Tastendruck oder per Web-Steuerung herunterzufahren. Hierfür wurde dem normalen Nutzer (\code{pi}) die Rechte gegeben, einzelne Befehle  als Admin ohne Passwortabfrage auszuführen. Diese Rechte können dem Nutzer durch Eintragung in die Konfigurationsdatei \code{/etc/sudoers} gegeben werden. Da eine fehlerhafte Änderung der Datei den kompletten Administratorzugang zum System versperren kann, wird die Datei mit dem Befehl \code{visudo} überarbeitet, der nach dem Editieren die Datei auf Fehler prüft. Die zusätzlichen Einträge in der Konfiguration sind dem \autoref{Lsudoers} zu entnehmen.\citep{sudoers}

\begin{lstlisting}[caption={Änderung der \code{/etc/sudoers}}, label={Lsudoers}]
# Cmnd alias specification
Cmnd_Alias VLP = /sbin/shutdown, /sbin/timedatectl

# User privilege specification
pi	ALL=(ALL) NOPASSWD: VLP
\end{lstlisting}

\section{IP-Adressen-Konfiguration}
Per Ethernet soll der Raspberry auf die IP-Adresse \code{192.168.1.111} konfiguriert werden, da diese IP-Adresse im Laserscanner als Host eingestellt war und an diesen die Daten vom Scanner übertragen werden. Die IP-Adresse des Raspberry Pi im WLAN wurde fest auf die gut zu merkende Adresse \code{10.10.10.10} geändert, hierüber erfolgt später der Zugriff auf die Weboberfläche (siehe auch \autoref{tab:ipAdressen}).

\begin{table}[]
\centering
\begin{tabular}{l|r|r|l|}
\cline{2-4}
                                                    & Schnittstelle & \multicolumn{2}{c|}{IP-Adresse bzw. Bereich} \\ \hline
\multicolumn{1}{|l|}{Laserscanner}                  & Ethernet      & 192.168.1.111        & statisch              \\ \hline
\multicolumn{1}{|l|}{\multirow{2}{*}{Raspberry Pi}} & Ethernet      & 192.168.2.110        & statisch              \\ \cline{2-4} 
\multicolumn{1}{|l|}{}                              & WiFi          & 10.10.10.10          & statisch              \\ \hline
\multicolumn{1}{|l|}{Client}                        & WiFi          & 10.10.10.100         & - 10.10.10.254        \\ \hline
\end{tabular}
\caption{IP-Adressen-Verteilung}
\label{tab:ipAdressen}
\end{table}

Die Konfiguration der IP-Adressen für den Raspberry erfolgt in der Konfigurationsdatei \code{/etc/network/interfaces} (siehe \autoref{interfaces}. \cite{accesspoint}

\todo{Original hinzufügen}
\begin{lstlisting}[caption={Konfiguration der \code{/etc/network/interfaces}}, label={interfaces}]
# localhost
auto lo
iface lo inet loopback

# Ethernet
auto eth0
iface eth0 inet static
	address 192.168.1.110
	netmask 255.255.255.0
	gateway 192.168.1.110

# WLAN
allow-hotplug wlan0
iface wlan0 inet static
	address 10.10.10.10
	netmask 255.255.255.0
	network 10.10.10.0
\end{lstlisting}

Zur Konfiguration der dynamischen IP-Adressen der Clients im WLAN wird ein DHCP-Server eingerichtet. Ein solcher Server weißt neuen Geräten -- beziehungsweise welchen, die länger nicht im Netzwerk waren -- automatisch eine neue, unverwendete IP-Adresse zu. Hierdurch benötigen die Clients keine spezielle Konfiguration und ihre IP-Einstellungen können auf dem üblichen Standardeinstellungen verbleiben (automatische IP-Adresse beziehen). Als DHCP-Server wird hier das Paket \code{dnsmasq} verwendet. Außer dem DHCP-Server bietet dieses Paket auch einen DNS-Server, der es erlaubt, den Geräten auch einen Hostname zuzuweisen. So wäre der Zugriff zum Beispiel über den Hostname raspberry.ip anstatt durch Eingabe der IP-Adresse möglich.

Die Konfiguration des DHCP-Servers ist vergleichsweise einfach und benötigt nur das verwendete Netzwerk-Interface, hier wlan0, den zu nutzenden IP-Bereich, die Netzmaske und die Zeit, nach der eine IP-Adresse an ein anderes Gerät vergeben werden darf, die sogenannte Lease-Time (siehe \autoref{dnsmasq}). \cite{accesspoint}

  
\begin{lstlisting}[caption={Konfiguration der \code{/etc/dnsmasq.conf}}, label={dnsmasq}]
interface=wlan0
  dhcp-range=10.10.10.100,10.10.10.254,255.255.255.0,24h
\end{lstlisting}

\section{Konfiguration als WLAN-Access-Point}
Um einen Zugriff auf die Python-Weboberfläche des Skriptes und die Konfiguration des Laserscanners zu ermöglichen, soll der Raspberry Pi selbst als WLAN-Access-Point fungieren. Hierzu das Paket \code{hostapd} verwendet. Zur Konfiguration werden die Einstellungen in die Datei \code{/etc/hostapd/hostapd.conf} geschrieben. \cite{accesspoint}

\begin{lstlisting}[caption={Konfiguration der \code{/etc/hostapd/hostapd.conf}}, label={hostapd}]
# WLAN-Router-Betrieb

# Schnittstelle und Treiber
interface=wlan0
#driver=nl80211

# WLAN-Konfiguration
ssid=VLPinterface
channel=1
hw_mode=g
ieee80211n=1
ieee80211d=1
country_code=DE
wmm_enabled=1

#WLAN-Verschluesselung
auth_algs=1
wpa=2
wpa_key_mgmt=WPA-PSK
rsn_pairwise=CCMP
wpa_passphrase=raspberry
\end{lstlisting}

\section{Autostart des Skriptes}
Damit das Skript vor der Messung mittels SSH-Zugang gestartet werden muss, wurde das Skript in den Autostart des Raspberry Pi eingetragen. Hierdurch erfolgt der Start des Skriptes unmittelbar nach dem Hochfahren des Betriebssystemes.

\begin{lstlisting}[caption={Startskript startVLP.sh}, label={startskript}]
su pi -c "python3 VdAutoStart.py"
exit 0
\end{lstlisting}

\chapter{Ausblick}
\label{c:ausblick}


%% Literatur
\renewcommand\UrlFont\itshape
\bibliography{Thesis}

\listoffigures
\listoftables
%\lstlistoflistings


\begin{appendices}

\chapter{Python-Scripte}
\label{a:skripte}
\section{vdAutoStart.py}
\label{a:vdAutoStart.py}
\lstinputlisting[language=Python]{../Quelltext/vdAutoStart.py}

\section{vdBuffer.py}
\label{a:vdBuffer.py}
\lstinputlisting[language=Python]{../Quelltext/vdBuffer.py}

\section{vdTransformer.py}
\label{a:vdTransformer.py}
\lstinputlisting[language=Python]{../Quelltext/vdTransformer.py}

\section{vdInterface.py}
\label{a:vdInterface.py}
\lstinputlisting[language=Python]{../Quelltext/vdInterface.py}

\section{vdHardware.py}
\label{a:vdHardware.py}
\lstinputlisting[language=Python]{../Quelltext/vdHardware.py}

\section{vdFile.py}
\label{a:vdFile.py}
\lstinputlisting[language=Python]{../Quelltext/vdFile.py}

\section{vdDataset.py}
\label{a:vdDataset.py}
\lstinputlisting[language=Python]{../Quelltext/vdDataset.py}

\section{vdPoint.py}
\label{a:vdPoint.py}
\lstinputlisting[language=Python]{../Quelltext/vdPoint.py}

\section{vdConfig.py}
\label{a:vdConfig.py}
\lstinputlisting[language=Python]{../Quelltext/vdConfig.py}

\section{convTxt2Obj.py}
\label{a:convToObj.py}
\lstinputlisting[language=Python]{../Quelltext/convTxt2Obj.py}

\chapter{Beispieldateien}

\section{Rohdaten vom Scanner}
\label{a:Rohdaten}

\section{Dateiformat für Datenspeicherung als Text}
\label{a:AusgabeTXT}
\lstinputlisting[firstline=1, lastline=20]{../Aufzeichnungen/test.txt}

\section{Dateiformat für Datenspeicherung als OBJ}
\label{a:AusgabeOBJ}
\lstinputlisting[firstline=1, lastline=20]{../Aufzeichnungen/test.txt.obj}


\end{appendices}

\newpage
\noindent\textbf{\large Erklärung}\\
Hiermit versichere ich, dass ich die beiliegende Bachelor-Thesis ohne fremde Hilfe selbstständig verfasst und nur die angegebenen Quellen und Hilfsmittel benutzt habe.\\
\\
Wörtlich oder dem Sinn nach aus anderen Werken entnommene Stellen sind unter Angabe der Quellen kenntlich gemacht. 
\\
\\
\\
\\
\noindent{Hamburg, den 12. Dez. 2017}
%\hline\\
\vspace{0.2cm}
\noindent{\small Ort, Datum \hspace{4.5cm} Florian Timm}


\end{document}